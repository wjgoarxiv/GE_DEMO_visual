<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 누출원 탐지 데모 목업</title> 
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script> 
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #121212; color: #E0E0E0; position: relative; width: 100vw; height: 100vh; }
        #container { width: 100%; height: 100%; display: block; position: fixed; top: 0; left: 0; z-index: 0; } 

        .ui-panel {
            position: absolute; 
            background: rgba(26, 29, 46, 0.88); 
            backdrop-filter: blur(12px) saturate(190%);
            -webkit-backdrop-filter: blur(12px) saturate(190%);
            border: 1px solid rgba(0, 207, 232, 0.25); 
            border-radius: 16px; 
            box-shadow: 0 8px 32px rgba(0, 207, 232, 0.2); 
            padding: 20px;
            color: #E0E0E0;
            z-index: 50; 
        }

        #topControls { 
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 60; 
            display: flex;
            gap: 10px;
        }
        .toggle-button { 
            padding: 10px 20px;
            font-size: 0.9rem;
            font-weight: 500;
            color: #00CFE8;
            background: transparent;
            border: 1px solid #00CFE8;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .toggle-button.active { 
            background: #00CFE8;
            color: #1A1D2E;
            box-shadow: 0 0 15px rgba(0, 207, 232, 0.5);
        }
        .toggle-button:not(.active):hover {
            background: rgba(0, 207, 232, 0.1);
        }

        /* Tab content styling removed as tabs are gone */
        
        #simulationContent { position: relative; width: 100%; height: 100%; } /* Always visible */
        #dataLogContent {
            /* Inherits .ui-panel styles */
            top: 80px; 
            left: 20px;
            right: 20px;
            bottom: 100px; 
            overflow-y: auto;
            display: none; /* Initially hidden */
        }
        #dataLogContent table, #aiSensorComparisonTable { width: 100%; border-collapse: collapse; font-size: 0.85rem; margin-top: 15px;}
        #dataLogContent th, #dataLogContent td, #aiSensorComparisonTable th, #aiSensorComparisonTable td { border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; text-align: right; }
        #dataLogContent th, #aiSensorComparisonTable th { background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0; z-index: 1; }


        #info { 
            /* Inherits .ui-panel styles */
            top: 80px; 
            left: 20px; 
            max-width: 300px; 
            font-size: 0.85rem; 
            /* z-index handled by .ui-panel */
        }
         #aiInfoPanel {
            /* Inherits .ui-panel styles */
            top: 80px; 
            right: 20px; 
            max-width: 300px; 
            font-size: 0.85rem; 
            max-height: calc(100vh - 180px); 
            overflow-y: auto; 
            display: none; /* Initially hidden */
        }

        #info h2, #aiInfoPanel h2 { font-size: 1.2rem; font-weight: 600; margin-bottom: 15px; color: #00CFE8; border-bottom: 1px solid rgba(0, 207, 232, 0.3); padding-bottom: 10px; }
        #info p, #aiInfoPanel p { margin-bottom: 8px; line-height: 1.5; }
        #info ul { list-style: none; padding: 0; margin: 0; }
        #info li { margin-bottom: 5px; } 
        #info li span, #aiInfoPanel span.ai-value { font-weight: 500; color: #FFFFFF; }

        #uiControls { 
            /* Inherits .ui-panel styles */
            bottom: 20px; 
            left: 20px; 
            right: 20px; 
            display: flex; 
            align-items: center; 
            gap: 15px; 
             /* z-index handled by .ui-panel */
        }
        
        .time-slider-container { flex-grow: 1; position: relative; padding-bottom: 25px; }
        #timeSlider { width: 100%; height: 10px; -webkit-appearance: none; appearance: none; background: rgba(0, 207, 232, 0.2); border-radius: 5px; outline: none; transition: background 0.3s; }
        #timeSlider:hover { background: rgba(0, 207, 232, 0.3); }
        #timeSlider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 22px; height: 22px; background: #00CFE8; border-radius: 50%; cursor: pointer; border: 3px solid #1A1D2E; box-shadow: 0 0 10px rgba(0, 207, 232, 0.7); transition: transform 0.2s; }
        #timeSlider::-webkit-slider-thumb:hover { transform: scale(1.1); }
        #timeSlider::-moz-range-thumb { width: 22px; height: 22px; background: #00CFE8; border-radius: 50%; cursor: pointer; border: 3px solid #1A1D2E; box-shadow: 0 0 10px rgba(0, 207, 232, 0.7); }

        .time-ticks { position: absolute; bottom: 0; left: 0; right: 0; display: flex; justify-content: space-between; padding: 0; font-size: 0.75rem; color: rgba(224, 224, 224, 0.7); }
        .time-ticks span { position: relative; display: inline-block; text-align: center; }
        .time-ticks span:first-child { transform: translateX(0%); } 
        .time-ticks span:last-child { transform: translateX(-100%); } 
        .time-ticks span:not(:first-child):not(:last-child) { transform: translateX(-50%); } 
        .time-ticks span::before { content: ''; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); width: 1px; height: 5px; background-color: rgba(224, 224, 224, 0.5); margin-bottom: 2px; }

        .control-button { padding: 10px 15px; font-size: 0.9rem; font-weight: 500; color: #E0E0E0; background: transparent; border: 1px solid rgba(0, 207, 232, 0.5); border-radius: 8px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px; min-width: 100px; justify-content: center; }
        .control-button svg { width: 16px; height: 16px; fill: #00CFE8; transition: fill 0.3s ease; }
        .control-button:hover { background: rgba(0, 207, 232, 0.2); border-color: rgba(0, 207, 232, 0.8); box-shadow: 0 0 15px rgba(0, 207, 232, 0.3); }
        .control-button:hover svg { fill: #FFFFFF; }
        .control-button:disabled { background: rgba(156, 163, 175, 0.2); border-color: rgba(156, 163, 175, 0.4); color: rgba(224, 224, 224, 0.5); cursor: not-allowed; }
        .control-button:disabled svg { fill: rgba(224, 224, 224, 0.5); }

        .sensor-label { color: #E0E0E0; background-color: rgba(26, 29, 46, 0.7); padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; position: absolute; transform: translateX(-50%) translateY(-160%); white-space: nowrap; pointer-events: none; border: 1px solid rgba(0, 207, 232, 0.3); z-index: 1; }

        #graphModal { 
            /* Inherits .ui-panel styles */
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 90%; max-width: 700px; 
            height: auto; max-height: 550px; 
            z-index: 100; /* Ensure graph modal is on top */
            display: none; 
            flex-direction: column; 
        }
        #graphModal h3 { font-size: 1.4rem; font-weight: 600; color: #00CFE8; margin-top: 0; margin-bottom: 20px; text-align: center; }
        #graphCanvasContainer { width: 100%; flex-grow: 1; min-height: 300px; }
        #closeGraphButton { position: absolute; top: 15px; right: 15px; background: transparent; color: #00CFE8; border: 1px solid #00CFE8; border-radius: 50%; width: 32px; height: 32px; font-size: 18px; line-height: 30px; text-align: center; cursor: pointer; transition: all 0.3s; }
        #closeGraphButton:hover { background: rgba(0, 207, 232, 0.2); color: #FFFFFF; box-shadow: 0 0 10px rgba(0, 207, 232, 0.5); }

        /* AI Panel Specific Styles */
        .ai-section { margin-bottom: 15px; padding-bottom: 12px; border-bottom: 1px solid rgba(0, 207, 232, 0.2); }
        .ai-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0;}
        .ai-section h3 { font-size: 1.0rem; font-weight: 600; color: #00CFE8; margin-bottom: 8px; }
        .ai-value { font-weight: bold; color: #FFFFFF; margin-left: 8px; }
        .ai-accuracy { font-size: 1.4rem; color: #4ade80; /* Green for high accuracy */ }
        #aiSensorComparisonTable td:nth-child(2) { color: #E0E0E0; } /* Actual PPM color */
        #aiSensorComparisonTable td:nth-child(3) { color: #facc15; } /* Predicted PPM color (Yellow) */

    </style>
</head>
<body>
    <div id="topControls"> 
        <button id="logToggleButton" class="toggle-button">Data Log</button> 
        <button id="aiToggleButton" class="toggle-button">AI 누출원 탐지</button> 
    </div>

    
    <div id="simulationContent">
        <canvas id="container"></canvas>
        
        
        <div id="info" class="ui-panel">
            <h2>시뮬레이션 정보</h2>
            <p>시간: <span id="timeDisplay" class="font-medium">0.00</span> / 300.00 초</p>
            <p>누출 지점: <span id="sourcePosDisplay" class="font-medium">미설정</span></p>
            <h3 class="font-semibold mt-3 mb-1 text-sm" style="color: #00CFE8;">센서 상태 (ID: 값 ppm)</h3>
            <ul id="sensorData"></ul>
            <button id="showAllSensorsGraph" class="control-button" style="width:100%; margin-top: 15px;">
                <svg viewBox="0 0 24 24"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6h-6zm-1.71 8.88l-4-4-6 6L1 14.59 0 16l4.29 4.29L10 14.59l4 4 7.71-7.71L20 12h2v6h-6l-1.71-1.71z"></path></svg>
                <span>전체 센서 그래프</span>
            </button>
        </div>

        
        <div id="aiInfoPanel" class="ui-panel"> 
             <h2 style="color: #00CFE8; font-size: 1.2rem; margin-bottom:15px; border-bottom: 1px solid rgba(0,207,232,0.3); padding-bottom:10px;">AI 누출원 탐지</h2>
            
            <div class="ai-section">
                <h3>모델 예측 정확도</h3>
                <p><span id="aiAccuracy" class="ai-accuracy ai-value">---</span> %</p>
            </div>

            <div class="ai-section">
                <h3>예측 누출원 위치</h3>
                <p>좌표 (X, Y, Z): <span id="aiPredictedSource" class="ai-value">---</span></p>
            </div>

            <div class="ai-section">
                <h3>센서 값 비교 (실제 vs 예측)</h3>
                 <div style="max-height: 200px; overflow-y: auto;"> 
                    <table id="aiSensorComparisonTable">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>실제</th>
                                <th>예측</th>
                            </tr>
                        </thead>
                        <tbody>
                            
                        </tbody>
                    </table>
                </div>
            </div>
        </div>


        
        <div id="uiControls" class="ui-panel">
            <button id="restartButton" class="control-button">
                <svg viewBox="0 0 24 24"><path d="M17.65 6.35A7.958 7.958 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
                <span>재시작</span>
            </button>
            <button id="playPauseButton" class="control-button">
                <svg id="playPauseIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                <span id="playPauseText">재생</span>
            </button>
            <div class="time-slider-container">
                <input type="range" id="timeSlider" min="0" max="300" value="0" step="0.1">
                <div class="time-ticks">
                    <span>0s</span><span>60s</span><span>120s</span><span>180s</span><span>240s</span><span>300s</span>
                </div>
            </div>
        </div>
        <div id="labelsContainer"></div>
    </div>

    
    <div id="dataLogContent" class="tab-content ui-panel">
        <h2 style="color: #00CFE8; font-size: 1.3rem; margin-bottom:15px; border-bottom: 1px solid rgba(0,207,232,0.3); padding-bottom:10px;">센서 데이터 로그</h2>
        <div style="max-height: calc(100% - 50px); overflow-y: auto;">
            <table id="sensorLogTable">
                <thead>
                    <tr>
                        <th>Time (s)</th>
                        <th>S1 (ppm)</th>
                        <th>S2 (ppm)</th>
                        <th>S3 (ppm)</th>
                        <th>S4 (ppm)</th>
                        <th>S5 (ppm)</th>
                        <th>S6 (ppm)</th>
                    </tr>
                </thead>
                <tbody>
                    
                </tbody>
            </table>
        </div>
    </div>
    
    
    
    <div id="graphModal" class="ui-panel">
        <button id="closeGraphButton">&times;</button>
        <h3 id="graphTitle">Sensor Time-Series Data</h3>
        <div id="graphCanvasContainer"><canvas id="sensorChart"></canvas></div>
    </div>

    <script type="module">
        // Ensure libraries are loaded
        if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined' || typeof Chart === 'undefined' || typeof SimplexNoise === 'undefined') {
            console.error("필수 라이브러리 로딩 실패.");
            document.body.innerHTML = '<div style="padding: 20px; text-align: center; color: red; font-size: 1.2em; background-color: #1A1D2E;">필수 라이브러리를 로드하는 데 실패했습니다. 페이지를 새로고침하거나 인터넷 연결을 확인하세요.</div>';
        } else {
            // --- Scene, Camera, Renderer Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1A1D2E); 
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(1.5, 2, 5.5); 
            const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('container'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xaaaaaa, 0.7); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0x00CFE8, 0.5); 
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.3); 
            pointLight.position.set(-5, -5, -5);
            scene.add(pointLight);

            // --- Controls ---
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2; 
            controls.maxDistance = 25; 

            // --- Boundaries ---
            const boundsDef = { xMin: -0.5, xMax: 2.5, yMin: -1.5, yMax: 0.5, zMin: -0.5, zMax: 1.5 };
            const boxSize = new THREE.Vector3(boundsDef.xMax - boundsDef.xMin, boundsDef.yMax - boundsDef.yMin, boundsDef.zMax - boundsDef.zMin);
            const boxCenter = new THREE.Vector3((boundsDef.xMin + boundsDef.xMax) / 2, (boundsDef.yMin + boundsDef.yMax) / 2, (boundsDef.zMin + boundsDef.zMax) / 2);
            const boxGeom = new THREE.BoxGeometry(boxSize.x, boxSize.y, boxSize.z);
            const boxMat = new THREE.MeshBasicMaterial({ color: 0x00CFE8, wireframe: true, transparent: true, opacity: 0.15 }); 
            const wireframeBox = new THREE.Mesh(boxGeom, boxMat);
            wireframeBox.position.copy(boxCenter);
            scene.add(wireframeBox);

            // --- Sensors Setup ---
            const DEFAULT_SENSOR_COORDS = [
                { id: 1, coords: [0,  0,  1] }, { id: 2, coords: [1,  0,  1] }, { id: 3, coords: [2,  0,  1] },
                { id: 4, coords: [0, -1,  0] }, { id: 5, coords: [1, -1,  0] }, { id: 6, coords: [2, -1,  0] },
            ];
            const sensors = [];
            const sensorMeshes = [];
            const sensorGeometry = new THREE.SphereGeometry(0.1, 24, 24);
            const initialSensorMaterial = new THREE.MeshPhongMaterial({ color: 0x007bff, emissive: 0x003f80, shininess: 90, specular: 0x555555 }); 
            const detectedSensorMaterial = new THREE.MeshPhongMaterial({ color: 0x00CFE8, emissive: 0x006774, shininess: 100, specular: 0x88ffff }); 
            const labelsContainer = document.getElementById('labelsContainer');
            const sensorDataUI = document.getElementById('sensorData');
            sensorDataUI.innerHTML = ''; 

            DEFAULT_SENSOR_COORDS.forEach(s_coord => {
                const sensorMesh = new THREE.Mesh(sensorGeometry, initialSensorMaterial.clone());
                sensorMesh.position.set(s_coord.coords[0], s_coord.coords[1], s_coord.coords[2]);
                sensorMesh.userData = { id: s_coord.id, type: 'sensor' };
                scene.add(sensorMesh);
                sensorMeshes.push(sensorMesh);
                const labelDiv = document.createElement('div');
                labelDiv.className = 'sensor-label';
                labelDiv.textContent = `S${s_coord.id}`;
                labelsContainer.appendChild(labelDiv);
                const sensorState = { 
                    id: s_coord.id, 
                    mesh: sensorMesh, 
                    label: labelDiv, 
                    position: sensorMesh.position.clone(), 
                    detected: false, 
                    detectionTime: -1, 
                    ppm: 0.0, 
                    predictedPpm: 0.0, 
                    ppmHistory: [], 
                    dataLog: [] 
                };
                sensors.push(sensorState);
                const listItem = document.createElement('li');
                listItem.innerHTML = `센서 ${s_coord.id}: <span id="sensor${s_coord.id}val" class="font-medium">0.00</span> ppm`;
                sensorDataUI.appendChild(listItem);
            });

            // --- Gas Source ---
            let gasSourceMesh = null;
            let gasSourcePosition = new THREE.Vector3();
            const sourceGeometry = new THREE.SphereGeometry(0.12, 24, 24); 
            const sourceMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500, emissive: 0xcc3700, shininess: 80, specular: 0xff8c00 }); 

            // --- Predicted Source Visualization ---
            let predictedSourceMesh = null;
            const predictedSourceGeometry = new THREE.SphereGeometry(0.15, 16, 16); 
            const predictedSourceMaterial = new THREE.MeshBasicMaterial({ color: 0x4ade80, wireframe: true, transparent: true, opacity: 0.7 }); 

            // --- Heatmap Visualization Setup ---
            const heatmapResolution = 15; 
            const voxelSize = new THREE.Vector3(
                boxSize.x / heatmapResolution, 
                boxSize.y / heatmapResolution, 
                boxSize.z / heatmapResolution
            );
            const heatmapPointsGeometry = new THREE.BufferGeometry();
            const heatmapPositions = [];
            const heatmapColors = [];
            const heatmapData = []; 

            for (let i = 0; i < heatmapResolution; i++) {
                for (let j = 0; j < heatmapResolution; j++) {
                    for (let k = 0; k < heatmapResolution; k++) {
                        const x = boundsDef.xMin + (i + 0.5) * voxelSize.x;
                        const y = boundsDef.yMin + (j + 0.5) * voxelSize.y;
                        const z = boundsDef.zMin + (k + 0.5) * voxelSize.z;
                        heatmapPositions.push(x, y, z);
                        heatmapColors.push(0, 0, 0); 
                        heatmapData.push({ position: new THREE.Vector3(x, y, z), concentration: 0 });
                    }
                }
            }
            heatmapPointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(heatmapPositions, 3));
            heatmapPointsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(heatmapColors, 3));

            const heatmapMaterial = new THREE.PointsMaterial({
                size: Math.min(voxelSize.x, voxelSize.y, voxelSize.z) * 1.8, 
                vertexColors: true,
                transparent: true,
                opacity: 0.6, 
                depthWrite: false,
                blending: THREE.AdditiveBlending 
            });
            const heatmapPoints = new THREE.Points(heatmapPointsGeometry, heatmapMaterial);
            scene.add(heatmapPoints);


            // --- Simulation Parameters ---
            let simulationTime = 0;
            const K_PPM_CONSTANT = 12; 
            const PPM_TIME_EXPONENT = 0.8; 
            const PPM_DIST_EXPONENT = 1.4; 
            const PPM_DIST_OFFSET = 0.1; 

            const maxSimulationTime = 300;
            const simulationSpeed = 10;
            let animationFrameId = null;
            let simulationRunning = false;
            let isPaused = true;
            let isInitializing = false;
            const clock = new THREE.Clock();

            // --- AI Simulation Variables ---
            let aiPredictionAccuracy = 98.0;
            let aiPredictedSourcePosition = new THREE.Vector3();

            // --- UI Elements ---
            const timeDisplayElement = document.getElementById('timeDisplay');
            const sourcePosDisplay = document.getElementById('sourcePosDisplay');
            const sensorValueSpans = {};
            sensors.forEach(s => sensorValueSpans[s.id] = document.getElementById(`sensor${s.id}val`));
            
            const restartButton = document.getElementById('restartButton');
            const playPauseButton = document.getElementById('playPauseButton');
            const playPauseIcon = document.getElementById('playPauseIcon');
            const playPauseText = document.getElementById('playPauseText');
            const timeSlider = document.getElementById('timeSlider');
            const showAllSensorsGraphButton = document.getElementById('showAllSensorsGraph');

            const playIconPath = "M8 5v14l11-7z";
            const pauseIconPath = "M6 19h4V5H6v14zm8-14v14h4V5h-4z";

            // --- Graph Elements ---
            const graphModal = document.getElementById('graphModal');
            const graphTitleElement = document.getElementById('graphTitle'); 
            const closeGraphButton = document.getElementById('closeGraphButton');
            const graphCanvas = document.getElementById('sensorChart').getContext('2d');
            let sensorChart = null;
            let activeSensorForGraph = null; 
            let isAllSensorsGraph = false; 

            // --- Tab Elements ---
            // const simTabButton = document.getElementById('simTabButton'); // No longer needed for switching logic
            const logToggleButton = document.getElementById('logToggleButton'); 
            const aiToggleButton = document.getElementById('aiToggleButton'); 
            const simulationContent = document.getElementById('simulationContent');
            const dataLogContent = document.getElementById('dataLogContent');
            const sensorLogTableBody = document.querySelector('#sensorLogTable tbody');
            const aiInfoPanel = document.getElementById('aiInfoPanel'); 
            const aiSensorComparisonTableBody = document.querySelector('#aiSensorComparisonTable tbody'); 
            const aiAccuracySpan = document.getElementById('aiAccuracy');
            const aiPredictedSourceSpan = document.getElementById('aiPredictedSource');

            let dataLogInterval = 1.0; 
            let lastLogTime = -1;

            // --- Toggle Logic ---
            logToggleButton.addEventListener('click', toggleLogPanel); 
            aiToggleButton.addEventListener('click', toggleAIPanel); 

            function toggleLogPanel() {
                const isVisible = dataLogContent.style.display === 'block';
                dataLogContent.style.display = isVisible ? 'none' : 'block';
                logToggleButton.classList.toggle('active', !isVisible); 
                if (!isVisible) {
                    updateDataLogTable(); 
                }
                // Hide other potentially overlapping UI elements when log is visible
                renderer.domElement.style.display = isVisible ? 'block' : 'none'; 
                info.style.display = isVisible ? 'block' : 'none';
                aiInfoPanel.style.display = 'none'; // Hide AI panel
                aiToggleButton.classList.remove('active'); // Deactivate AI button
                labelsContainer.style.display = isVisible ? 'block' : 'none';
                // No need to manage simTabButton active state
            }

            function toggleAIPanel() {
                const isVisible = aiInfoPanel.style.display === 'block';
                aiInfoPanel.style.display = isVisible ? 'none' : 'block';
                aiToggleButton.classList.toggle('active', !isVisible); 
                if (!isVisible) {
                    updateAIDetectionTab(); 
                }
                 // Ensure simulation view elements are visible when AI panel is toggled
                 renderer.domElement.style.display = 'block'; 
                 info.style.display = 'block';
                 labelsContainer.style.display = 'block';
                 // Hide log panel if AI panel is shown
                 dataLogContent.style.display = 'none';
                 logToggleButton.classList.remove('active');
                 // Update predicted source visibility based on panel state
                 if(predictedSourceMesh) predictedSourceMesh.visible = !isVisible && simulationTime > 0;
            }


            // --- Chart Functions ---
            function initOrUpdateChart(sensorOrSensors, isAllMode = false) {
                if (sensorChart) sensorChart.destroy();
                isAllSensorsGraph = isAllMode;

                const datasets = [];
                const chartColors = ['#00CFE8', '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#C9CBCF'];


                let commonTimeLabels = [];
                const maxTimeForLabels = (simulationRunning || isPaused && simulationTime > 0) ? simulationTime : maxSimulationTime; 
                const currentTimeStep = 0.5; 
                for (let t = 0; t <= maxTimeForLabels; t += currentTimeStep) { 
                    commonTimeLabels.push(t.toFixed(1));
                }
                 if (commonTimeLabels.length === 0 || parseFloat(commonTimeLabels[commonTimeLabels.length -1]) < maxTimeForLabels) {
                     commonTimeLabels.push(maxTimeForLabels.toFixed(1)); 
                }
                commonTimeLabels = [...new Set(commonTimeLabels)]; 
                commonTimeLabels.sort((a, b) => parseFloat(a) - parseFloat(b));
                if(commonTimeLabels.length === 0 && maxTimeForLabels === 0) commonTimeLabels.push("0.0"); 


                if (isAllMode) {
                    graphTitleElement.textContent = "모든 센서 PPM 비교";
                    sensors.forEach((s, index) => {
                        const sensorDataPoints = commonTimeLabels.map(tLabel => {
                            const tNum = parseFloat(tLabel);
                            if (s.detectionTime === -1 || tNum < s.detectionTime) return 0; 
                            const historyPointsBeforeT = s.ppmHistory.filter(p => p.time <= tNum + 0.01); 
                            if (historyPointsBeforeT.length > 0) {
                                return historyPointsBeforeT[historyPointsBeforeT.length - 1].value;
                            }
                            return 0; 
                        });

                        datasets.push({
                            label: `Sensor ${s.id}`,
                            data: sensorDataPoints,
                            borderColor: chartColors[index % chartColors.length],
                            backgroundColor: 'transparent',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 1,
                            pointHoverRadius: 4,
                        });
                    });
                    activeSensorForGraph = null; 
                } else {
                    const sensor = sensorOrSensors;
                    if (!sensor || !sensor.ppmHistory) return;
                    activeSensorForGraph = sensor;
                    graphTitleElement.textContent = `센서 ${sensor.id} - PPM 변화 그래프`;
                    
                    const sensorDataPoints = commonTimeLabels.map(tLabel => {
                        const tNum = parseFloat(tLabel);
                         if (sensor.detectionTime === -1 || tNum < sensor.detectionTime) return 0; 
                         const historyPointsBeforeT = sensor.ppmHistory.filter(p => p.time <= tNum + 0.01);
                         if (historyPointsBeforeT.length > 0) {
                            return historyPointsBeforeT[historyPointsBeforeT.length - 1].value;
                         }
                         return 0;
                    });

                    datasets.push({
                        label: `Sensor ${sensor.id} PPM`,
                        data: sensorDataPoints,
                        borderColor: chartColors[0],
                        backgroundColor: 'rgba(0, 207, 232, 0.2)',
                        fill: true,
                        tension: 0.2,
                        pointRadius: 3,
                        pointBackgroundColor: '#00CFE8',
                        pointBorderColor: '#1A1D2E',
                        pointHoverRadius: 5
                    });
                }
                
                const data = {
                    labels: commonTimeLabels,
                    datasets: datasets
                };

                const config = {
                    type: 'line', data: data,
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: {
                            x: { title: { display: true, text: '시간 (초)', color: '#E0E0E0' }, ticks: { color: '#B0B0B0', autoSkip: true, maxTicksLimit: 15 }, grid: { color: 'rgba(0, 207, 232, 0.1)' } }, 
                            y: { title: { display: true, text: 'PPM', color: '#E0E0E0' }, beginAtZero: true, suggestedMax: 10, ticks: { color: '#B0B0B0' }, grid: { color: 'rgba(0, 207, 232, 0.1)' } }
                        },
                        animation: { duration: 0 }, 
                        plugins: { 
                            legend: { display: isAllMode, labels: { color: '#E0E0E0' } }, 
                            tooltip: { mode: 'index', intersect: false } 
                        },
                        interaction: { mode: 'index', intersect: false },
                    }
                };
                
                let overallMaxPPM = 10;
                datasets.forEach(ds => {
                    const maxInDs = Math.max(...ds.data, 0);
                    if (maxInDs > overallMaxPPM) overallMaxPPM = maxInDs;
                });
                config.options.scales.y.suggestedMax = Math.max(10, overallMaxPPM * 1.1);


                try {
                    sensorChart = new Chart(graphCanvas, config);
                    graphModal.style.display = 'flex';
                } catch (e) {
                    console.error("Chart.js initialization error:", e);
                }
            }
            
            showAllSensorsGraphButton.addEventListener('click', () => initOrUpdateChart(sensors, true));


            function updateChart() { 
                 if (!sensorChart) return;

                let commonTimeLabels = [];
                const maxTimeForLabels = (simulationRunning || isPaused && simulationTime > 0) ? simulationTime : maxSimulationTime;
                const currentTimeStep = 0.5;
                for (let t = 0; t <= maxTimeForLabels; t += currentTimeStep) { 
                    commonTimeLabels.push(t.toFixed(1));
                }
                 if (commonTimeLabels.length === 0 || parseFloat(commonTimeLabels[commonTimeLabels.length -1]) < maxTimeForLabels) {
                     commonTimeLabels.push(maxTimeForLabels.toFixed(1));
                }
                commonTimeLabels = [...new Set(commonTimeLabels)];
                commonTimeLabels.sort((a, b) => parseFloat(a) - parseFloat(b));
                 if(commonTimeLabels.length === 0 && maxTimeForLabels === 0) commonTimeLabels.push("0.0");
                sensorChart.data.labels = commonTimeLabels;


                if (isAllSensorsGraph) {
                    sensorChart.data.datasets.forEach((dataset, index) => {
                        const sensor = sensors[index];
                        if (sensor && sensor.ppmHistory) {
                             const sensorDataPoints = commonTimeLabels.map(tLabel => {
                                const tNum = parseFloat(tLabel);
                                if (sensor.detectionTime === -1 || tNum < sensor.detectionTime) return 0;
                                const historyPointsBeforeT = sensor.ppmHistory.filter(p => p.time <= tNum + 0.01);
                                return historyPointsBeforeT.length > 0 ? historyPointsBeforeT[historyPointsBeforeT.length - 1].value : 0;
                            });
                            dataset.data = sensorDataPoints;
                        }
                    });
                } else if (activeSensorForGraph && activeSensorForGraph.ppmHistory) {
                     const sensorDataPoints = commonTimeLabels.map(tLabel => {
                        const tNum = parseFloat(tLabel);
                        if (activeSensorForGraph.detectionTime === -1 || tNum < activeSensorForGraph.detectionTime) return 0;
                        const historyPointsBeforeT = activeSensorForGraph.ppmHistory.filter(p => p.time <= tNum + 0.01);
                        return historyPointsBeforeT.length > 0 ? historyPointsBeforeT[historyPointsBeforeT.length - 1].value : 0;
                    });
                    sensorChart.data.datasets[0].data = sensorDataPoints;
                } else {
                    return; 
                }
                
                let overallMaxPPM = 10;
                 sensorChart.data.datasets.forEach(ds => {
                    const maxInDs = Math.max(...ds.data, 0);
                    if (maxInDs > overallMaxPPM) overallMaxPPM = maxInDs;
                });
                sensorChart.options.scales.y.suggestedMax = Math.max(10, overallMaxPPM * 1.1);
                sensorChart.update('none');
            }
            closeGraphButton.addEventListener('click', () => { graphModal.style.display = 'none'; activeSensorForGraph = null; isAllSensorsGraph = false; if(sensorChart) { sensorChart.destroy(); sensorChart = null; } });

            function updateDataLogTable() {
                sensorLogTableBody.innerHTML = ''; 
                const loggedTimes = {}; 

                sensors.forEach(sensor => {
                    sensor.dataLog.forEach(logEntry => {
                        loggedTimes[logEntry.time.toFixed(1)] = true;
                    });
                });

                const sortedTimes = Object.keys(loggedTimes).map(parseFloat).sort((a, b) => a - b);

                sortedTimes.forEach(time => {
                    const row = sensorLogTableBody.insertRow();
                    const timeCell = row.insertCell();
                    timeCell.textContent = time.toFixed(1);

                    sensors.forEach(sensor => {
                        const cell = row.insertCell();
                        const logEntry = sensor.dataLog.find(entry => entry.time.toFixed(1) === time.toFixed(1));
                        cell.textContent = logEntry ? logEntry.value.toFixed(2) : '0.00';
                    });
                });
            }

            // --- AI Tab Update Function ---
            function updateAIDetectionTab() {
                // Update Accuracy
                const baseAccuracy = 97.0;
                const timeFactor = Math.min(1, simulationTime / maxSimulationTime); 
                aiPredictionAccuracy = baseAccuracy + timeFactor * 2.0 + (Math.random() - 0.5) * 0.5; 
                aiAccuracySpan.textContent = aiPredictionAccuracy.toFixed(2);

                // Update Predicted Source
                const maxError = 0.5; 
                const errorFactor = Math.max(0.1, 1 - timeFactor * 0.9); 
                const errorX = (Math.random() - 0.5) * maxError * errorFactor;
                const errorY = (Math.random() - 0.5) * maxError * errorFactor;
                const errorZ = (Math.random() - 0.5) * maxError * errorFactor;
                aiPredictedSourcePosition.copy(gasSourcePosition).add(new THREE.Vector3(errorX, errorY, errorZ));
                aiPredictedSourcePosition.x = Math.max(boundsDef.xMin, Math.min(boundsDef.xMax, aiPredictedSourcePosition.x));
                aiPredictedSourcePosition.y = Math.max(boundsDef.yMin, Math.min(boundsDef.yMax, aiPredictedSourcePosition.y));
                aiPredictedSourcePosition.z = Math.max(boundsDef.zMin, Math.min(boundsDef.zMax, aiPredictedSourcePosition.z));
                aiPredictedSourceSpan.textContent = `(${aiPredictedSourcePosition.x.toFixed(1)}, ${aiPredictedSourcePosition.y.toFixed(1)}, ${aiPredictedSourcePosition.z.toFixed(1)})`;
                
                if (predictedSourceMesh) {
                    predictedSourceMesh.position.copy(aiPredictedSourcePosition);
                    predictedSourceMesh.visible = simulationTime > 0 && aiInfoPanel.style.display === 'block'; // Show only if panel is visible
                }

                // Update Sensor Comparison Table
                aiSensorComparisonTableBody.innerHTML = ''; 
                sensors.forEach(s => {
                    const noise = (Math.random() - 0.5) * s.ppm * 0.05; 
                    s.predictedPpm = Math.max(0, s.ppm + noise); 

                    const row = aiSensorComparisonTableBody.insertRow();
                    row.insertCell().textContent = `S${s.id}`;
                    row.insertCell().textContent = s.ppm.toFixed(2);
                    row.insertCell().textContent = s.predictedPpm.toFixed(2);
                });
            }


            async function initializeSimulation() {
                if (isInitializing) return;
                isInitializing = true;
                restartButton.disabled = true; playPauseButton.disabled = true;

                simulationRunning = false; isPaused = true;
                playPauseIcon.innerHTML = `<path d="${playIconPath}"></path>`; playPauseText.textContent = "재생";
                simulationTime = 0; timeSlider.value = 0; clock.stop();
                lastLogTime = -1; 

                if (gasSourceMesh) scene.remove(gasSourceMesh);
                if (predictedSourceMesh) scene.remove(predictedSourceMesh); 

                gasSourcePosition = new THREE.Vector3( THREE.MathUtils.randFloat(boundsDef.xMin + 0.5, boundsDef.xMax - 0.5), THREE.MathUtils.randFloat(boundsDef.yMin + 0.5, boundsDef.yMax - 0.5), THREE.MathUtils.randFloat(boundsDef.zMin + 0.5, boundsDef.zMax - 0.5) );
                gasSourceMesh = new THREE.Mesh(sourceGeometry, sourceMaterial);
                gasSourceMesh.position.copy(gasSourcePosition);
                scene.add(gasSourceMesh);
                sourcePosDisplay.textContent = `(${gasSourcePosition.x.toFixed(1)}, ${gasSourcePosition.y.toFixed(1)}, ${gasSourcePosition.z.toFixed(1)})`;

                predictedSourceMesh = new THREE.Mesh(predictedSourceGeometry, predictedSourceMaterial);
                predictedSourceMesh.visible = false; 
                scene.add(predictedSourceMesh);


                sensors.forEach(s => {
                    s.detected = false; s.detectionTime = -1; s.ppm = 0.0; s.predictedPpm = 0.0;
                    s.mesh.material = initialSensorMaterial.clone();
                    sensorValueSpans[s.id].textContent = "0.00"; sensorValueSpans[s.id].style.color = '#FFFFFF';
                    s.ppmHistory = []; 
                    s.dataLog = []; 
                });
                
                // Reset Heatmap
                const colors = heatmapPoints.geometry.attributes.color.array;
                for (let i = 0; i < heatmapData.length; i++) {
                    heatmapData[i].concentration = 0;
                    colors[i * 3] = 0; colors[i * 3 + 1] = 0; colors[i * 3 + 2] = 0; 
                }
                heatmapPoints.geometry.attributes.color.needsUpdate = true;


                await setSimulationStateToTime(0); 
                if (activeSensorForGraph || isAllSensorsGraph) initOrUpdateChart(isAllSensorsGraph ? sensors : activeSensorForGraph, isAllSensorsGraph);
                updateDataLogTable(); 
                updateAIDetectionTab(); 

                isInitializing = false; restartButton.disabled = false; playPauseButton.disabled = false;
                if (!animationFrameId) animate();
             }
            
            const gasDiffusionRadiusFactor = 0.02; 
            // --- Heatmap Color Function ---
            function concentrationToColor(concentration) {
                const maxConcentrationForColor = 60; 
                const normalized = Math.min(1, Math.max(0, concentration / maxConcentrationForColor));
                
                const color = new THREE.Color();
                // Blue -> Cyan -> Green -> Yellow -> Red gradient
                if (normalized < 0.2) { 
                     color.setHSL(0.66 - normalized * 0.8, 1.0, 0.5 + normalized * 1.5); 
                } else if (normalized < 0.4) { 
                    color.setHSL(0.5 - (normalized - 0.2) * 1.6, 1.0, 0.8 - (normalized - 0.2) * 0.5); 
                } else if (normalized < 0.7) { 
                    color.setHSL(0.18 - (normalized - 0.4) * 0.6 , 1.0, 0.7 - (normalized - 0.4) * 0.5); 
                } else { 
                    color.setHSL(0.0 + (1.0 - normalized) * 0.3, 1.0, 0.55 + (1.0 - normalized) * 0.2); 
                }
                
                const alpha = Math.min(1.0, 0.1 + normalized * 0.9); 

                return { r: color.r, g: color.g, b: color.b, a: alpha }; 
            }


            async function setSimulationStateToTime(targetVirtualTime) { 
                simulationTime = Math.max(0, Math.min(targetVirtualTime, maxSimulationTime));
                timeSlider.value = simulationTime;
                timeDisplayElement.textContent = `${simulationTime.toFixed(2)} / ${maxSimulationTime.toFixed(2)} 초`;
                const targetActualTime = simulationTime / simulationSpeed; 

                const currentDiffusionRadius = 0.05 + simulationTime * gasDiffusionRadiusFactor; 
                
                sensors.forEach(s => {
                    s.ppmHistory = []; 
                    s.dataLog = []; 
                    const distanceToSource = s.position.distanceTo(gasSourcePosition);
                    let sensorActualDetectionTime = -1; 

                    if (distanceToSource <= currentDiffusionRadius) {
                        sensorActualDetectionTime = Math.max(0, (distanceToSource - 0.05) / gasDiffusionRadiusFactor);
                        if (targetVirtualTime >= sensorActualDetectionTime) {
                            s.detected = true; s.detectionTime = sensorActualDetectionTime; 
                            s.mesh.material = detectedSensorMaterial.clone();
                            const timeSinceDefinitiveDetection = Math.max(0, targetVirtualTime - s.detectionTime);
                            s.ppm = (K_PPM_CONSTANT * (timeSinceDefinitiveDetection ** PPM_TIME_EXPONENT)) / (distanceToSource**PPM_DIST_EXPONENT + PPM_DIST_OFFSET);
                        } else {
                            s.detected = false; s.ppm = 0.0; s.detectionTime = -1; 
                            s.mesh.material = initialSensorMaterial.clone();
                        }
                    } else {
                        s.detected = false; s.ppm = 0.0; s.detectionTime = -1;
                        s.mesh.material = initialSensorMaterial.clone();
                    }

                    // Reconstruct history and log based on calculated detection time
                    for (let t = 0; t <= targetVirtualTime; t += 0.5) { 
                        let currentPPMForHist = 0;
                        if (s.detectionTime !== -1 && t >= s.detectionTime) {
                            const timeSinceActualDetectionForHist = Math.max(0, t - s.detectionTime);
                            currentPPMForHist = (K_PPM_CONSTANT * (timeSinceActualDetectionForHist ** PPM_TIME_EXPONENT)) / (distanceToSource**PPM_DIST_EXPONENT + PPM_DIST_OFFSET);
                        }
                        s.ppmHistory.push({ time: t, value: currentPPMForHist });
                        if (Math.abs(t % dataLogInterval) < 0.01 || t === 0 || t.toFixed(1) === targetVirtualTime.toFixed(1)) {
                            if (!s.dataLog.length || s.dataLog[s.dataLog.length - 1].time.toFixed(1) !== t.toFixed(1)) {
                                 s.dataLog.push({time: t, value: currentPPMForHist});
                            }
                        }
                    }
                    // Ensure the final point matches the target time and calculated PPM
                    const lastHistEntry = s.ppmHistory[s.ppmHistory.length -1];
                    if (!lastHistEntry || lastHistEntry.time < targetVirtualTime) {
                        s.ppmHistory.push({ time: targetVirtualTime, value: s.ppm });
                    } else if (lastHistEntry.time > targetVirtualTime) { 
                         s.ppmHistory.pop(); 
                         s.ppmHistory.push({ time: targetVirtualTime, value: s.ppm });
                    } else { 
                        lastHistEntry.value = s.ppm; 
                    }

                     const lastLogEntry = s.dataLog[s.dataLog.length -1];
                     if (!lastLogEntry || lastLogEntry.time < targetVirtualTime) {
                         s.dataLog.push({ time: targetVirtualTime, value: s.ppm });
                     } else if (lastLogEntry.time > targetVirtualTime){
                         s.dataLog.pop();
                         s.dataLog.push({ time: targetVirtualTime, value: s.ppm });
                     } else {
                         lastLogEntry.value = s.ppm;
                     }

                    s.ppmHistory.sort((a,b) => a.time - b.time); 
                    s.dataLog.sort((a,b) => a.time - b.time); 


                    sensorValueSpans[s.id].textContent = s.ppm.toFixed(2);
                    sensorValueSpans[s.id].style.color = s.detected ? '#00CFE8' : '#FFFFFF';
                });


                // --- Update Heatmap ---
                const colors = heatmapPoints.geometry.attributes.color.array;

                for (let i = 0; i < heatmapData.length; i++) {
                    const voxel = heatmapData[i];
                    const distanceToSource = voxel.position.distanceTo(gasSourcePosition);
                    let concentration = 0;
                    
                    const voxelDetectionTime = Math.max(0, (distanceToSource - 0.05) / gasDiffusionRadiusFactor); 

                    if (simulationTime >= voxelDetectionTime) {
                         const timeSinceVoxelDetection = Math.max(0, simulationTime - voxelDetectionTime);
                         concentration = (K_PPM_CONSTANT * (timeSinceVoxelDetection ** PPM_TIME_EXPONENT)) / (distanceToSource**PPM_DIST_EXPONENT + PPM_DIST_OFFSET);
                    }
                    
                    voxel.concentration = concentration;

                    const colorData = concentrationToColor(concentration); 
                    
                    colors[i * 3] = colorData.r;
                    colors[i * 3 + 1] = colorData.g;
                    colors[i * 3 + 2] = colorData.b;

                     // Hide very low concentrations by making them black (for AdditiveBlending)
                    if (concentration < 0.1) { // Threshold to hide low values
                         colors[i * 3] = 0; colors[i * 3 + 1] = 0; colors[i * 3 + 2] = 0;
                    }
                }
                // No global opacity adjustment needed for AdditiveBlending

                heatmapPoints.geometry.attributes.color.needsUpdate = true;

                // Update AI Tab (always update data, visibility handled by tab switching)
                updateAIDetectionTab();

                if (activeSensorForGraph || isAllSensorsGraph) updateChart();
                if (dataLogContent.classList.contains('active')) updateDataLogTable();
                // No need to update AI tab here, it's done above
                renderer.render(scene, camera);
            }

            function updateSimulation(actualDeltaTime) {
                if (!simulationRunning || isPaused || !gasSourceMesh) return;
                const virtualDeltaTime = actualDeltaTime * simulationSpeed;
                simulationTime += virtualDeltaTime;
                simulationTime = Math.min(simulationTime, maxSimulationTime);
                timeSlider.value = simulationTime;
                timeDisplayElement.textContent = `${simulationTime.toFixed(2)} / ${maxSimulationTime.toFixed(2)} 초`;

                const currentDiffusionRadius = 0.05 + simulationTime * gasDiffusionRadiusFactor;
                
                // --- Update Heatmap in real-time ---
                const colors = heatmapPoints.geometry.attributes.color.array;

                for (let i = 0; i < heatmapData.length; i++) {
                    const voxel = heatmapData[i];
                    const distanceToSource = voxel.position.distanceTo(gasSourcePosition);
                    let concentration = 0;
                    
                    const voxelDetectionTime = Math.max(0, (distanceToSource - 0.05) / gasDiffusionRadiusFactor); 

                    if (simulationTime >= voxelDetectionTime) {
                         const timeSinceVoxelDetection = Math.max(0, simulationTime - voxelDetectionTime);
                         concentration = (K_PPM_CONSTANT * (timeSinceVoxelDetection ** PPM_TIME_EXPONENT)) / (distanceToSource**PPM_DIST_EXPONENT + PPM_DIST_OFFSET);
                    }
                    
                    voxel.concentration = concentration;
                    const colorData = concentrationToColor(concentration); 
                    
                    colors[i * 3] = colorData.r;
                    colors[i * 3 + 1] = colorData.g;
                    colors[i * 3 + 2] = colorData.b;

                     if (concentration < 0.1) { 
                         colors[i * 3] = 0; colors[i * 3 + 1] = 0; colors[i * 3 + 2] = 0;
                    }
                }
                // No global opacity adjustment needed for AdditiveBlending

                heatmapPoints.geometry.attributes.color.needsUpdate = true;


                sensors.forEach(s => { 
                    const distanceToSource = s.position.distanceTo(gasSourcePosition); 
                    const sensorDetectionTime = Math.max(0, (distanceToSource - 0.05) / gasDiffusionRadiusFactor); 

                    if (!s.detected && simulationTime >= sensorDetectionTime) {
                        s.detected = true; 
                        s.detectionTime = sensorDetectionTime; 
                        s.mesh.material = detectedSensorMaterial.clone();
                    }
                    if (s.detected) {
                        const timeSinceDetection = Math.max(0, simulationTime - s.detectionTime);
                        s.ppm = (K_PPM_CONSTANT * (timeSinceDetection ** PPM_TIME_EXPONENT)) / (distanceToSource**PPM_DIST_EXPONENT + PPM_DIST_OFFSET);
                        sensorValueSpans[s.id].textContent = s.ppm.toFixed(2); sensorValueSpans[s.id].style.color = '#00CFE8';
                        
                        if (!s.ppmHistory.length || simulationTime - s.ppmHistory[s.ppmHistory.length - 1].time >= 0.5) {
                             if (s.ppmHistory.length > 600) s.ppmHistory.shift();
                             s.ppmHistory.push({ time: simulationTime, value: s.ppm });
                        }
                    } else {
                         s.ppm = 0.0;
                         sensorValueSpans[s.id].textContent = "0.00"; 
                         sensorValueSpans[s.id].style.color = '#FFFFFF';
                         if (!s.ppmHistory.length || simulationTime - s.ppmHistory[s.ppmHistory.length - 1].time >= 0.5) {
                             s.ppmHistory.push({ time: simulationTime, value: 0.0 });
                         }
                    }
                });
                
                if (simulationTime - lastLogTime >= dataLogInterval || lastLogTime < 0) {
                    sensors.forEach(s => {
                        s.dataLog.push({time: simulationTime, value: s.ppm });
                    });
                    lastLogTime = simulationTime;
                    if (dataLogContent.classList.contains('active')) { 
                        updateDataLogTable();
                    }
                }

                // Update AI Tab only if its panel is visible
                if (aiInfoPanel.style.display === 'block') {
                    updateAIDetectionTab();
                }

                if (activeSensorForGraph || isAllSensorsGraph) updateChart();
                if (simulationTime >= maxSimulationTime && simulationRunning) {
                    simulationRunning = false; isPaused = true;
                    playPauseIcon.innerHTML = `<path d="${playIconPath}"></path>`; playPauseText.textContent = "재생";
                    playPauseButton.disabled = true;
                }
            }

            function updateLabels() { 
                 sensors.forEach(s => {
                    const vector = s.mesh.position.clone().project(camera);
                    const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                    const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
                    s.label.style.left = `${x}px`; s.label.style.top = `${y}px`;
                    s.label.style.display = vector.z < 1 && x > 0 && x < renderer.domElement.clientWidth && y > 0 && y < renderer.domElement.clientHeight ? 'block' : 'none';
                });
            }

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            function onMouseClick(event) {
                // Prevent click-through on UI elements
                if (event.target.closest('#uiControls') || event.target.closest('#graphModal') || event.target.closest('#info') || event.target.closest('#topControls') || event.target.closest('#dataLogContent') || event.target.closest('#aiInfoPanel')) return; // Updated selector

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(sensorMeshes, false); 
                if (intersects.length > 0) {
                    const clickedSensorMesh = intersects[0].object;
                    if (clickedSensorMesh.userData && clickedSensorMesh.userData.id !== undefined) { 
                        const sensorId = clickedSensorMesh.userData.id;
                        const sensorData = sensors.find(s => s.id === sensorId);
                        if (sensorData) {
                           initOrUpdateChart(sensorData, false); 
                        }
                    }
                }
            }
            window.addEventListener('click', onMouseClick, false);

            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                const actualDeltaTime = clock.getDelta();
                if (simulationRunning && !isPaused) {
                    updateSimulation(actualDeltaTime);
                }
                controls.update(); 
                // Always update labels as they are part of the main simulation view
                updateLabels(); 
                
                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => { 
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                // Always update labels on resize
                updateLabels();
                
                if (sensorChart) sensorChart.resize();
            }, false);

            restartButton.addEventListener('click', initializeSimulation);
            playPauseButton.addEventListener('click', () => {
                if (isInitializing) return;
                isPaused = !isPaused;
                if (!isPaused) {
                    simulationRunning = true; clock.start();
                    playPauseIcon.innerHTML = `<path d="${pauseIconPath}"></path>`; playPauseText.textContent = "일시정지";
                    if (simulationTime >= maxSimulationTime) { initializeSimulation(); playPauseIcon.innerHTML = `<path d="${pauseIconPath}"></path>`; playPauseText.textContent = "일시정지"; }
                } else {
                    playPauseIcon.innerHTML = `<path d="${playIconPath}"></path>`; playPauseText.textContent = "재생";
                }
                if (!animationFrameId && !isPaused) animate();
            });
            timeSlider.addEventListener('input', async (event) => {
                if (isInitializing) return;
                if (!isPaused) { isPaused = true; playPauseIcon.innerHTML = `<path d="${playIconPath}"></path>`; playPauseText.textContent = "재생"; }
                const newTime = parseFloat(event.target.value);
                await setSimulationStateToTime(newTime);
            });
            
            initializeSimulation(); // Start the simulation on load
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI 누출원 탐지 시스템</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: 'Inter', sans-serif; 
      background-color: #121212; 
      color: #E0E0E0; 
      position: relative; 
      width: 100vw; 
      height: 100vh; 
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .right-panel {
      flex-grow: 1;
      background: #1A1D2E;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .ui-panel {
      position: absolute; 
      background: rgba(26, 29, 46, 0.88); 
      backdrop-filter: blur(12px) saturate(190%);
      -webkit-backdrop-filter: blur(12px) saturate(190%);
      border: 1px solid rgba(0, 207, 232, 0.25); 
      border-radius: 16px; 
      box-shadow: 0 8px 32px rgba(0, 207, 232, 0.2); 
      padding: 20px;
      color: #E0E0E0;
      z-index: 50; 
    }

    #topControls { 
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 60; 
      display: flex;
      gap: 10px;
    }

    .toggle-button { 
      padding: 10px 20px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #00CFE8;
      background: transparent;
      border: 1px solid #00CFE8;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .toggle-button.active { 
      background: #00CFE8;
      color: #1A1D2E;
      box-shadow: 0 0 15px rgba(0, 207, 232, 0.5);
    }
    
    .toggle-button:not(.active):hover {
      background: rgba(0, 207, 232, 0.1);
    }

    #overlay-buttons {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 60;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #overlay-buttons button {
      padding: 10px 15px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #00CFE8;
      background: transparent;
      border: 1px solid #00CFE8;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #overlay-buttons button:hover {
      background: rgba(0, 207, 232, 0.1);
      box-shadow: 0 0 15px rgba(0, 207, 232, 0.3);
    }

    #popup {
      position: fixed;
      display: none;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 29, 46, 0.88);
      backdrop-filter: blur(12px) saturate(190%);
      -webkit-backdrop-filter: blur(12px) saturate(190%);
      border: 1px solid rgba(0, 207, 232, 0.25);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 207, 232, 0.2);
      font-size: 14px;
      z-index: 100;
      width: 50vw;
      min-width: 300px;
      overflow: auto;
      max-height: 80vh;
    }

    #popup-header {
      cursor: move;
      padding: 15px 20px;
      border-bottom: 1px solid rgba(0, 207, 232, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 16px 16px 0 0;
      color: #00CFE8;
      font-weight: 600;
    }

    #popup-content {
      width: 90%;
      padding: 20px;
      margin: 0 auto;
    }

    #closeButton {
      background: transparent;
      color: #00CFE8;
      border: 1px solid #00CFE8;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      font-size: 16px;
      line-height: 26px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    #closeButton:hover {
      background: rgba(0, 207, 232, 0.2);
      color: #FFFFFF;
      box-shadow: 0 0 10px rgba(0, 207, 232, 0.5);
    }

    .info-panel {
      top: 80px; 
      left: 20px; 
      max-width: 300px; 
      font-size: 0.85rem;
    }

    .info-panel h2 {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #00CFE8;
      border-bottom: 1px solid rgba(0, 207, 232, 0.3);
      padding-bottom: 10px;
    }

    .info-panel h3 {
      font-size: 1.0rem;
      font-weight: 600;
      color: #00CFE8;
      margin-bottom: 8px;
    }

    .sensor-value {
      font-weight: 500;
      color: #FFFFFF;
    }

    #graphModal { 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      width: 90%; 
      max-width: 700px; 
      height: auto; 
      max-height: 550px; 
      z-index: 110;
      display: none; 
      flex-direction: column; 
    }

    #graphModal h3 { 
      font-size: 1.4rem; 
      font-weight: 600; 
      color: #00CFE8; 
      margin-top: 0; 
      margin-bottom: 20px; 
      text-align: center; 
    }

    #graphCanvasContainer { 
      width: 100%; 
      flex-grow: 1; 
      min-height: 300px; 
    }

    #closeGraphButton { 
      position: absolute; 
      top: 15px; 
      right: 15px; 
      background: transparent; 
      color: #00CFE8; 
      border: 1px solid #00CFE8; 
      border-radius: 50%; 
      width: 32px; 
      height: 32px; 
      font-size: 18px; 
      line-height: 30px; 
      text-align: center; 
      cursor: pointer; 
      transition: all 0.3s; 
    }

    #closeGraphButton:hover { 
      background: rgba(0, 207, 232, 0.2); 
      color: #FFFFFF; 
      box-shadow: 0 0 10px rgba(0, 207, 232, 0.5); 
    }

    /* Status display styling */
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-normal {
      background-color: #4ade80; /* green */
    }

    .status-warning {
      background-color: #facc15; /* yellow */
    }

    .status-danger {
      background-color: #f87171; /* red */
    }

    /* Sensor Labels */
    .sensor-label {
      color: #E0E0E0;
      background-color: rgba(26, 29, 46, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      position: absolute;
      transform: translateX(-50%) translateY(-160%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(0, 207, 232, 0.3);
      z-index: 1;
    }

    /* Control buttons styling */
    .control-button {
      padding: 10px 15px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #E0E0E0;
      background: transparent;
      border: 1px solid rgba(0, 207, 232, 0.5);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 100px;
      justify-content: center;
    }

    .control-button:hover {
      background: rgba(0, 207, 232, 0.2);
      border-color: rgba(0, 207, 232, 0.8);
      box-shadow: 0 0 15px rgba(0, 207, 232, 0.3);
    }
  </style>
</head>

<body>

  <div class="container">
    <div class="right-panel" id="viewer"></div>
  </div>

  <div id="topControls">
    <button id="dataLogButton" class="toggle-button">데이터 로그</button>
    <button id="aiDetectionButton" class="toggle-button">AI 누출원 탐지</button>
  </div>
  <div id="overlay-buttons">
    <button onclick="LearningStart()">AI 학습</button>
    <button onclick="DemoStart()">데모 시작</button>
    <button onclick="LeakDetection()">AI 기반 누출 추정</button>
    <button onclick="Dispersion()">암모니아 확산 양상</button>
  </div>

  <div id="popup" class="ui-panel">
    <div id="popup-header">
      <span>시뮬레이션 정보</span>
      <button id="closeButton" onclick="popup.style.display='none'; popupLocked=false;">✖</button>
    </div>
    <div id="popup-content"></div>
  </div>

  <div id="info" class="ui-panel info-panel" style="top: 80px; left: 140px; max-width: 300px;">
    <h2>시뮬레이션 정보</h2>
    <p>현재 상태: <span id="statusDisplay" class="sensor-value">대기중</span></p>
    <p>누출 지점: <span id="leakPointDisplay" class="sensor-value">미설정</span></p>
    <h3>센서 상태 (ppm)</h3>
    <ul id="sensorData" style="list-style: none; padding: 0;"></ul>
    <button id="showAllSensorsGraph" class="control-button" style="width:100%; margin-top: 15px;">
      <span>전체 센서 그래프 보기</span>
    </button>
  </div>

  <div id="aiInfoPanel" class="ui-panel info-panel" style="right: 20px; left: auto; display: none;">
    <h2>AI 누출원 탐지</h2>
    <div style="margin-bottom: 15px; padding-bottom: 12px; border-bottom: 1px solid rgba(0, 207, 232, 0.2);">
      <h3>모델 예측 정확도</h3>
      <p><span id="aiAccuracy" style="font-size: 1.4rem; color: #4ade80; font-weight: bold;">---</span> %</p>
    </div>
    <div style="margin-bottom: 15px; padding-bottom: 12px; border-bottom: 1px solid rgba(0, 207, 232, 0.2);">
      <h3>예측 누출원 위치</h3>
      <p>좌표 (X, Y, Z): <span id="aiPredictedSource" class="sensor-value">---</span></p>
    </div>
    <div style="margin-bottom: 15px;">
      <h3>센서 값 비교</h3>
      <div style="max-height: 200px; overflow-y: auto;">
        <table id="aiSensorComparisonTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem; margin-top: 10px;">
          <thead>
            <tr>
              <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8;">센서</th>
              <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8;">실제값</th>
              <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8;">예측값</th>
            </tr>
          </thead>
          <tbody id="aiSensorComparison">
            <!-- 센서 데이터가 여기에 추가됩니다 -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="dataLogContent" class="ui-panel" style="top: 80px; left: 20px; right: 20px; bottom: 20px; display: none; overflow-y: auto;">
    <h2 style="font-size: 1.2rem; font-weight: 600; margin-bottom: 15px; color: #00CFE8; border-bottom: 1px solid rgba(0, 207, 232, 0.3); padding-bottom: 10px;">센서 데이터 로그</h2>
    <div style="max-height: calc(100% - 50px); overflow-y: auto;">
      <table id="sensorLogTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem; margin-top: 15px;">
        <thead>
          <tr>
            <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0;">시간 (초)</th>
            <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0;">센서 #1</th>
            <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0;">센서 #2</th>
            <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0;">센서 #3</th>
            <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0;">센서 #4</th>
            <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0;">센서 #5</th>
            <th style="border: 1px solid rgba(0, 207, 232, 0.3); padding: 8px; background-color: rgba(0, 207, 232, 0.1); color: #00CFE8; position: sticky; top: 0;">센서 #6</th>
          </tr>
        </thead>
        <tbody id="logTableBody">
          <!-- Log data will be added here -->
        </tbody>
      </table>
    </div>
  </div>

  <div id="graphModal" class="ui-panel">
    <button id="closeGraphButton" onclick="closeGraphModal()">✖</button>
    <h3 id="graphTitle">센서 시계열 데이터</h3>
    <div id="graphCanvasContainer">
      <canvas id="sensorChart"></canvas>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

  <script>
    let scene, camera, renderer, loader, controls, currentModel;
    const popup = document.getElementById('popup');
    const popupHeader = document.getElementById('popup-header');
    let popupLocked = true;  // 팝업 잠금 여부 (AI 학습 시 true)

    // Toggle buttons for data log and AI detection
    const dataLogButton = document.getElementById('dataLogButton');
    const aiDetectionButton = document.getElementById('aiDetectionButton');
    const dataLogContent = document.getElementById('dataLogContent');
    const aiInfoPanel = document.getElementById('aiInfoPanel');
    const closeGraphButton = document.getElementById('closeGraphButton');
    const showAllSensorsGraphButton = document.getElementById('showAllSensorsGraph');

    // Add event listeners for toggle buttons
    dataLogButton.addEventListener('click', () => {
      const isVisible = dataLogContent.style.display === 'block';
      dataLogContent.style.display = isVisible ? 'none' : 'block';
      dataLogButton.classList.toggle('active', !isVisible);
      
      // Hide AI panel when showing data log
      if (!isVisible) {
        aiInfoPanel.style.display = 'none';
        aiDetectionButton.classList.remove('active');
      }
    });

    aiDetectionButton.addEventListener('click', () => {
      const isVisible = aiInfoPanel.style.display === 'block';
      aiInfoPanel.style.display = isVisible ? 'none' : 'block';
      aiDetectionButton.classList.toggle('active', !isVisible);
      
      // Hide data log when showing AI panel
      if (!isVisible) {
        dataLogContent.style.display = 'none';
        dataLogButton.classList.remove('active');
      }
      
      // Update AI panel data when showing
      if (!isVisible) {
        updateAIPanel();
      }
    });

    // Function to close graph modal
    function closeGraphModal() {
      document.getElementById('graphModal').style.display = 'none';
    }

    // Function to update the AI panel with simulation data
    function updateAIPanel() {
      // Update accuracy with a random value between 97-99%
      const accuracy = (97 + Math.random() * 2).toFixed(2);
      document.getElementById('aiAccuracy').textContent = accuracy;
      
      // Set a predicted position with slight randomization
      const predictedPos = {
        x: (3.5 + (Math.random() * 0.4 - 0.2)).toFixed(2),
        y: (-1 + (Math.random() * 0.4 - 0.2)).toFixed(2),
        z: (2 + (Math.random() * 0.4 - 0.2)).toFixed(2)
      };
      document.getElementById('aiPredictedSource').textContent = `(${predictedPos.x}, ${predictedPos.y}, ${predictedPos.z})`;
      
      // Update the comparison table
      const aiSensorComparison = document.getElementById('aiSensorComparison');
      aiSensorComparison.innerHTML = '';
      
      // Generate some sample sensor data
      for (let i = 1; i <= 6; i++) {
        const actualValue = (Math.random() * 10).toFixed(2);
        const predictedValue = (parseFloat(actualValue) + (Math.random() - 0.5)).toFixed(2);
        
        const row = document.createElement('tr');
        const sensorCell = document.createElement('td');
        sensorCell.textContent = `센서 #${i}`;
        sensorCell.style.border = '1px solid rgba(0, 207, 232, 0.3)';
        sensorCell.style.padding = '8px';
        
        const actualCell = document.createElement('td');
        actualCell.textContent = actualValue;
        actualCell.style.border = '1px solid rgba(0, 207, 232, 0.3)';
        actualCell.style.padding = '8px';
        
        const predictedCell = document.createElement('td');
        predictedCell.textContent = predictedValue;
        predictedCell.style.border = '1px solid rgba(0, 207, 232, 0.3)';
        predictedCell.style.padding = '8px';
        predictedCell.style.color = '#facc15'; // Yellow for predicted values
        
        row.appendChild(sensorCell);
        row.appendChild(actualCell);
        row.appendChild(predictedCell);
        aiSensorComparison.appendChild(row);
      }
    }

    // Function to update sensor status panel
    function updateSensorDataPanel() {
      const sensorData = document.getElementById('sensorData');
      sensorData.innerHTML = '';
      
      // Generate random sensor values
      for (let i = 1; i <= 6; i++) {
        const value = (Math.random() * 10).toFixed(2);
        const statusClass = parseFloat(value) > 7 ? 'status-danger' : 
                          parseFloat(value) > 3 ? 'status-warning' : 'status-normal';
        
        const listItem = document.createElement('li');
        listItem.style.marginBottom = '8px';
        listItem.style.display = 'flex';
        listItem.style.alignItems = 'center';
        
        const statusIndicator = document.createElement('span');
        statusIndicator.className = `status-indicator ${statusClass}`;
        
        const label = document.createElement('span');
        label.innerHTML = `센서 #${i}: <span class="sensor-value">${value}</span> ppm`;
        
        listItem.appendChild(statusIndicator);
        listItem.appendChild(label);
        sensorData.appendChild(listItem);
      }
      
      // Update leak point display
      document.getElementById('leakPointDisplay').textContent = '(3.5, -1.0, 2.0)';
      
      // Update status display
      document.getElementById('statusDisplay').textContent = '모니터링 중';
    }

    // All sensors graph functionality
    showAllSensorsGraphButton.addEventListener('click', () => {
      const graphModal = document.getElementById('graphModal');
      const graphTitle = document.getElementById('graphTitle');
      graphTitle.textContent = '전체 센서 데이터 시계열 그래프';
      
      // Create a chart
      const ctx = document.getElementById('sensorChart').getContext('2d');
      
      // Generate random data for each sensor
      const datasets = [];
      const labels = [];
      
      // Create time labels
      for (let i = 0; i <= 30; i++) {
        labels.push(i);
      }
      
      // Create datasets for each sensor
      for (let i = 1; i <= 6; i++) {
        const color = `hsl(${(i * 60) % 360}, 70%, 50%)`;
        const data = [];
        
        // Generate random values with some continuity
        let lastVal = Math.random() * 5;
        for (let j = 0; j <= 30; j++) {
          lastVal = Math.max(0, lastVal + (Math.random() - 0.5) * 2);
          data.push(lastVal);
        }
        
        datasets.push({
          label: `센서 #${i}`,
          data: data,
          borderColor: color,
          backgroundColor: color + '33', // Add transparency
          tension: 0.3,
          fill: false
        });
      }
      
      // Destroy previous chart instance if it exists
      if (window.sensorChart) {
        window.sensorChart.destroy();
      }
      
      // Create new chart
      window.sensorChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: '시간 (초)',
                color: '#E0E0E0'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              },
              ticks: {
                color: '#E0E0E0'
              }
            },
            y: {
              title: {
                display: true,
                text: '농도 (ppm)',
                color: '#E0E0E0'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              },
              ticks: {
                color: '#E0E0E0'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#E0E0E0'
              }
            }
          }
        }
      });
      
      graphModal.style.display = 'flex';
    });

    // Initialize the info panel with sample data
    updateSensorDataPanel();

    init();
    loadModel('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/model_GE-v1.glb');


    function init() {
      const container = document.getElementById('viewer');
      scene = new THREE.Scene();
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      scene.background = null;
      container.appendChild(renderer.domElement);

      const aspect = container.clientWidth / container.clientHeight;
      const dist = 15;
      camera = new THREE.OrthographicCamera(-dist * aspect, dist * aspect, dist, -dist, 0.1, 1000);
      camera.position.set(0, 0, -dist);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      loader = new THREE.GLTFLoader();

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      animate();
    }

    function loadModel(path) {
      if (currentModel) scene.remove(currentModel);
      loader.load(path, function (gltf) {
        currentModel = gltf.scene;
        scene.add(currentModel);
      }, undefined, function (error) {
        console.error('모델 로드 실패:', error);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // 장비 상태 정육면체 생성 함수
    function addStatusCubeAt(x, y, z) {
      const geometry = new THREE.BoxGeometry(2, 10, 3);
      const material = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5, // 0 = 완전 투명, 1 = 불투명
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, z);
      scene.add(cube);
    }

    const clickableCubes = [];
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let INTERSECTED = null;

    // 라벨 큐브 생성
    function addLabeledCube(x, y, z, name, size = 1, imagePath = null) {
      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.5
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, z);
      cube.userData.name = name;
      cube.userData.image = imagePath;
      scene.add(cube);
      clickableCubes.push(cube);

      // 라벨
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = '40px Arial';
      ctx.fillStyle = 'red';
      ctx.fillText(name, 10, 50);
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(5, 2.5, 1);
      sprite.position.set(x, y + size, z);
      scene.add(sprite);
    }
    // 텍스트 흐릿하게 나오는 현상 처리 필요 (참고: https://namocom.tistory.com/191)

    function LearningStart() {
      popupLocked = true;  // AI 학습에서 생성된 팝업은 고정
      const name = "AI 학습";
      const imgPath = "https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png";

      const html = `
      <strong>${name}</strong><br>
      <img src="${imgPath}" alt="${name}" style="width:100%; max-height:300px; object-fit:contain; margin-top:5px;"><br>
      <p style="margin-top: 5px;">AI 학습 시작 화면입니다.</p>
    `;

      document.getElementById('popup-content').innerHTML = html;
      
      popup.style.top = '10%';
      popup.style.left = '40%';
      popup.style.display = 'block';

    }

    let leakChart;             // Chart.js 인스턴스
    let leakTimer;             // setInterval 타이머
    let leakData = [];         // 전체 데이터 배열
    let leakIndex = 0;         // 현재 시점 인덱스

    function DemoStart() {
      clearInterval(leakTimer);  // 이전 실행 중지
      leakChart?.destroy();      // 기존 그래프 제거
      leakData = [];
      leakIndex = 0;

      const speedFactor = 5; // ✅ n배 빠르게 (예: 5배 빠르게)

      // fetch('data/leak_7.csv') // 로컬 파일인 경우
      fetch('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leak_7.csv') 
        .then(response => response.text())
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headers = lines[0].split(',');
          const timeIdx = headers.indexOf('Time (sec)');

          // value 컬럼 인덱스들 (value1, value2, ...)
          const valueIndices = headers
            .map((h, i) => ({ name: h.trim(), idx: i }))
            .filter(obj => obj.name !== 'Time (sec)');

          for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            const time = parseFloat(parts[timeIdx]);
            const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
            leakData.push({ x: time, yValues: values });
          }

          document.getElementById('popup-content').innerHTML = `<canvas id="leakChart" width="100%" height="100%"></canvas>`;
          //popup.style.top = '10%';
          //popup.style.left = '20%';
          popup.style.display = 'block';

          const ctx = document.getElementById('leakChart').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: valueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60) % 360}, 70%, 50%)`,
                backgroundColor: `hsla(${(index * 60) % 360}, 70%, 50%, 0.2)`,
                fill: false,
                tension: 0.2
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]' },
                  min: 0,
                  //max: 10
                },
                y: {
                  title: { display: true, text: 'NH3 [ppm]' },
                  min: 0,
                  //max: 100
                }
              },
              responsive: true,
              maintainAspectRatio: false
            }
          });

          // 1초 간격으로 값 추가
          leakTimer = setInterval(() => {
            if (leakIndex < leakData.length) {
              const point = leakData[leakIndex];
              point.yValues.forEach((val, idx) => {
                leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
              });
              // 👉 x축 max 값을 현재 시간 + 1로 실시간 업데이트
              leakChart.options.scales.x.max = leakData[leakIndex].x + 1;
              leakChart.update();
              leakIndex++;
            } else {
              clearInterval(leakTimer); // 종료
            }
          }, 1000 / speedFactor);
        })
        .catch(error => {
          document.getElementById('popup-content').innerHTML = `<p style="color:red;">CSV 로드 실패: ${error}</p>`;
          popup.style.display = 'block';
        });

    }


    function LeakDetection() {
      clearInterval(leakTimer);
      leakChart?.destroy();
      leakData = [];
      leakIndex = 0;

      const speedFactor = 5;  // n배 빠르게

      // 기존 큐브 찾기 또는 새로 생성
      let statusCube1;
      let statusCube2;
      let statusCube3;
      /*
      const existing = scene.children.find(obj => obj.name === 'statusCube');
      if (existing) {
        statusCube = existing;
      } else {
        const geometry = new THREE.BoxGeometry(2, 10, 3);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        statusCube = new THREE.Mesh(geometry, material);
        statusCube.position.set(3.5, -1, 2);
        statusCube.name = 'statusCube';
        scene.add(statusCube);
      }
      */
      const geometry = new THREE.BoxGeometry(2, 10, 3);

      statusCube1 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
      statusCube2 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
      statusCube3 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));

      statusCube1.position.set(3.5, -1, 2);
      statusCube2.position.set(-0.4, -1, 2);
      statusCube3.position.set(-4.3, -1, 2);

      statusCube1.name = 'GE#1';
      statusCube2.name = 'GE#2';
      statusCube3.name = 'GE#3';

      scene.add(statusCube1);
      scene.add(statusCube2);
      scene.add(statusCube3);

      // fetch('data/leakDetection.csv') // 로컬 파일인 경우
      fetch('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leakDetection.csv') 
        .then(response => response.text())
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headers = lines[0].split(',');
          const timeIdx = headers.indexOf('Time (sec)');

          // value 컬럼 인덱스들 (value1, value2, ...)
          const valueIndices = headers
            .map((h, i) => ({ name: h.trim(), idx: i }))
            .filter(obj => obj.name !== 'Time (sec)');

          for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            const time = parseFloat(parts[timeIdx]);
            const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
            leakData.push({ x: time, yValues: values });
          }

          document.getElementById('popup-content').innerHTML = `<canvas id="leakChart" width="600" height="600"></canvas>`;
          popup.style.top = '10%';
          popup.style.left = '40%';
          popup.style.display = 'block';

          const ctx = document.getElementById('leakChart').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: valueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60) % 360}, 70%, 50%)`,
                backgroundColor: `hsla(${(index * 60) % 360}, 70%, 50%, 0.2)`,
                fill: false,
                tension: 0.2
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]' },
                  min: 0,
                  //max: 10
                },
                y: {
                  title: { display: true, text: 'NH3 [ppm]' },
                  min: 0,
                  //max: 100
                }
              },
              responsive: true,
              maintainAspectRatio: false
            }
          });

          // 1초 간격으로 값 추가
          leakTimer = setInterval(() => {
            if (leakIndex < leakData.length) {
              const point = leakData[leakIndex];
              point.yValues.forEach((val, idx) => {
                leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
              });
              // 👉 x축 max 값을 현재 시간 + 1로 실시간 업데이트
              leakChart.options.scales.x.max = leakData[leakIndex].x + 1;

              // 동적으로 큐브 색상 업데이트
              const red1 = Math.floor(point.yValues[0] * 255);
              const green1 = Math.floor((1 - point.yValues[0]) * 255);
              statusCube1.material.color.setRGB(red1 / 255, green1 / 255, 0);

              const red2 = Math.floor(point.yValues[1] * 255);
              const green2 = Math.floor((1 - point.yValues[1]) * 255);
              statusCube2.material.color.setRGB(red2 / 255, green2 / 255, 0);

              const red3 = Math.floor(point.yValues[2] * 255);
              const green3 = Math.floor((1 - point.yValues[2]) * 255);
              statusCube3.material.color.setRGB(red3 / 255, green3 / 255, 0);

              console.log(point.yValues[0]);
              leakChart.update();
              leakIndex++;
            } else {
              clearInterval(leakTimer); // 종료
            }
          }, 1000 / speedFactor);
        })
        .catch(error => {
          document.getElementById('popup-content').innerHTML = `<p style="color:red;">CSV 로드 실패: ${error}</p>`;
          popup.style.display = 'block';
        });
    }


    function Dispersion() {


      // [1] 외부 박스 크기 정의
      const boxWidth = 13.8;
      const boxHeight = 21.5;
      const boxDepth = 7.5;
      const halfW = boxWidth / 2;
      const halfH = boxHeight / 2;
      const halfD = boxDepth / 2;

      // [2] 외부 박스 그리기
      const outerBox = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      const outerEdges = new THREE.EdgesGeometry(outerBox);
      const outerMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
      const outerWireframe = new THREE.LineSegments(outerEdges, outerMaterial);
      scene.add(outerWireframe);

      // [3] 내부 장애물 정의 (center + size)
      const obstacles = [
        { center: new THREE.Vector3(3.5, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-0.4, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-4.3, -1, 2), size: new THREE.Vector3(2, 10, 3) }
      ];

      // min/max 계산 및 시각화
      obstacles.forEach(obs => {
        const halfSize = obs.size.clone().multiplyScalar(0.5);
        obs.min = obs.center.clone().sub(halfSize);
        obs.max = obs.center.clone().add(halfSize);

        const geom = new THREE.BoxGeometry(obs.size.x, obs.size.y, obs.size.z);
        const edges = new THREE.EdgesGeometry(geom);
        const mat = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const wire = new THREE.LineSegments(edges, mat);
        wire.position.copy(obs.center); // 중심 좌표 기준 위치
        scene.add(wire);
      });

      // 9개 그리드 정의 (3x3 → x,z 방향 분할)
      // ✅ XY 평면상 그리드 설정
      const gridCountX = 3;
      const gridCountY = 3;
      const gridWidth = boxWidth / gridCountX;
      const gridHeight = boxHeight / gridCountY;

      const gridPlanes = [];
      for (let i = 0; i < gridCountX; i++) {
        for (let j = 0; j < gridCountY; j++) {
          const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide
          });
          const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(gridWidth, gridHeight),
            material
          );
          // XY 평면 → 회전 없음
          plane.position.set(
            -halfW + gridWidth * (i + 0.5),
            -halfH + gridHeight * (j + 0.5),
            -halfD + 0.01  // XY 평면에 z 고정
          );
          scene.add(plane);
          gridPlanes.push({ mesh: plane, count: 0 });
        }
      }
      // [4] 누출원 위치
      const leakSource = new THREE.Vector3(4.8, 2.0, 0.4);

      // [5] 파티클 설정
      const particles = [];
      const maxParticles = 1000;
      const interval = 100;
      const speed = 0.02;
      const maxAge = 100.0;

      function createParticle() {
        const direction = new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 2 - 1,
          Math.random() * 2 - 1
        ).normalize();

        const material = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.6
        });

        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 6, 6),
          material
        );
        particle.position.copy(leakSource);
        particle.userData = {
          direction,
          age: 0
        };
        scene.add(particle);
        particles.push(particle);
      }

      setInterval(() => {
        if (particles.length < maxParticles) createParticle();
      }, interval);

      function animateDispersion() {
        requestAnimationFrame(animateDispersion);

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          const delta = p.userData.direction.clone().multiplyScalar(speed);
          const nextPos = p.position.clone().add(delta);

          // [6-1] 외부 박스 반사
          if (Math.abs(nextPos.x) > halfW) {
            p.userData.direction.reflect(new THREE.Vector3(1, 0, 0));
            p.position.x = Math.sign(p.position.x) * halfW;
          }
          if (Math.abs(nextPos.y) > halfH) {
            p.userData.direction.reflect(new THREE.Vector3(0, 1, 0));
            p.position.y = Math.sign(p.position.y) * halfH;
          }
          if (Math.abs(nextPos.z) > halfD) {
            p.userData.direction.reflect(new THREE.Vector3(0, 0, 1));
            p.position.z = Math.sign(p.position.z) * halfD;
          }

          // [6-2] 내부 장애물 반사
          for (const obs of obstacles) {
            if (
              nextPos.x > obs.min.x && nextPos.x < obs.max.x &&
              nextPos.y > obs.min.y && nextPos.y < obs.max.y &&
              nextPos.z > obs.min.z && nextPos.z < obs.max.z
            ) {
              const entry = p.position;

              const distToMin = entry.clone().sub(obs.min);
              const distToMax = obs.max.clone().sub(entry);
              const absMin = new THREE.Vector3(Math.abs(distToMin.x), Math.abs(distToMin.y), Math.abs(distToMin.z));
              const absMax = new THREE.Vector3(Math.abs(distToMax.x), Math.abs(distToMax.y), Math.abs(distToMax.z));

              const minDist = Math.min(
                absMin.x, absMin.y, absMin.z,
                absMax.x, absMax.y, absMax.z
              );

              let normal = new THREE.Vector3(0, 0, 0);
              if (minDist === absMin.x) normal.set(-1, 0, 0);
              else if (minDist === absMax.x) normal.set(1, 0, 0);
              else if (minDist === absMin.y) normal.set(0, -1, 0);
              else if (minDist === absMax.y) normal.set(0, 1, 0);
              else if (minDist === absMin.z) normal.set(0, 0, -1);
              else if (minDist === absMax.z) normal.set(0, 0, 1);

              p.userData.direction.reflect(normal);
            }
          }

          // 위치 이동
          p.position.add(p.userData.direction.clone().multiplyScalar(speed));

          // [7] 색상 및 투명도 변화
          p.userData.age += speed * 5;
          const t = Math.min(p.userData.age / maxAge, 1);
          const r = 1;
          const g = t < 0.5 ? t * 2 : 1;
          const b = 0;
          const alpha = t < 0.5 ? 0.6 : 0.6 * (1 - (t - 0.5) * 2);

          p.material.color.setRGB(r, g, b);
          p.material.opacity = alpha;

          // [8] 수명 초과 시 제거
          if (p.userData.age > maxAge) {
            scene.remove(p);
            particles.splice(i, 1);
          }

          // 그리드별 입자 수 초기화
          gridPlanes.forEach(g => g.count = 0);

          // XY 평면 기준으로 입자 분포 카운팅
          particles.forEach(p => {
            const px = p.position.x + halfW;
            const py = p.position.y + halfH;

            const i = Math.floor(px / gridWidth);
            const j = Math.floor(py / gridHeight);

            if (i >= 0 && i < gridCountX && j >= 0 && j < gridCountY) {
              const index = i * gridCountY + j;
              gridPlanes[index].count++;
            }
          });

          // 최댓값 계산
          const counts = gridPlanes.map(g => g.count);
          const maxCount = Math.max(...counts);
          const minCount = Math.min(...counts);

          // 색상 업데이트 (초록 → 빨강)
          gridPlanes.forEach(g => {
            const t = maxCount > 0 ? (g.count - minCount) / (maxCount - minCount || 1) : 0;
            const r = t;
            const gVal = 1 - t;
            g.mesh.material.color.setRGB(r, gVal, 0);
          });

        }

        renderer.render(scene, camera);
      }

      animateDispersion();
    }

    let isDragging = false, offsetX = 0, offsetY = 0;

    popupHeader.addEventListener('mousedown', (e) => {
      isDragging = true;
      const rect = popup.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        popup.style.left = (e.clientX - offsetX) + 'px';
        popup.style.top = (e.clientY - offsetY) + 'px';
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('resize', () => {
      const container = document.getElementById('viewer');
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    window.addEventListener('click', (event) => {

      // 1. 데모 버튼이면 raycaster 검사 생략
      if (
        event.target.closest('#popup') ||
        event.target.closest('#overlay-buttons')
      ) return;

      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableCubes);

      if (intersects.length > 0) {
        // 정상 클릭 시 팝업 표시
        const obj = intersects[0].object;
        const name = obj.userData.name;
        const imgPath = obj.userData.image || 'default.png';

        const html = `
        <strong>${name}</strong><br>
        <img src="${imgPath}" alt="${name}" style="width:100%; max-height:150px; object-fit:contain; margin-top:5px;"><br>
        <em>(x: ${event.clientX}, y: ${obj.position.y.toFixed(2)}, z: ${obj.position.z.toFixed(2)})</em>
      `;
        document.getElementById('popup-content').innerHTML = html;
        popup.style.left = event.offsetX + 10 + 'px';
        popup.style.top = event.offsetY + 10 + 'px';
        popup.style.display = 'block';

      } else {
        if (!popupLocked) popup.style.display = 'none';  // 잠금된 팝업은 닫히지 않음
      }
    });

    window.addEventListener('mousemove', (event) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableCubes);

      if (intersects.length > 0) {
        if (INTERSECTED != intersects[0].object) {
          if (INTERSECTED) {
            INTERSECTED.material.color.set(0xff0000); // 원래 색으로
          }
          INTERSECTED = intersects[0].object;
          INTERSECTED.material.color.set(0xffff00); // hover 시 노란색
        }
      } else {
        if (INTERSECTED) {
          INTERSECTED.material.color.set(0xff0000);
          INTERSECTED = null;
        }
      }
    });



    addLabeledCube(3.45, 1.11, -0.565, 'Sensor #1', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-0.507, 1.11, -0.565, 'Sensor #2', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-4.46, 1.11, -0.565, 'Sensor #3', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(4.26, 1.11, 0.360, 'Sensor #4', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(0.304, 1.11, 0.360, 'Sensor #5', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-3.65, 1.11, 0.360, 'Sensor #6', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');

  </script>

</body>

</html>

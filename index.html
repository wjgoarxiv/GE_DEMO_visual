<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI 누출원 탐지 시스템</title>
  <style>
    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
      background: #f8f9fa;
      color: #333333;
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* Project Title Styles - Simple Text Title */
    .project-title {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10001;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 16px;
      border-radius: 8px;
      text-align: center;
      white-space: nowrap;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      font-weight: 700;
      font-size: 1.1rem;
      letter-spacing: -0.02em;
      transition: opacity 0.3s ease;
      pointer-events: none; /* Make it non-interactive */
    }

    .project-title-main {
      color: #007bff;
      font-weight: 800;
    }

    .project-title:hover {
      opacity: 0.8;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .right-panel {
      flex-grow: 1;
      background: #ffffff;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* 훈련 데이터셋 버튼 - Original Clean Design */
    #training-dataset-button {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10000;
      padding: 12px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      color: #6f42c1;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #6f42c1;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      min-width: 180px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #training-dataset-button:hover {
      background: rgba(111, 66, 193, 0.1);
      box-shadow: 0 8px 20px rgba(111, 66, 193, 0.2);
      transform: translateY(-2px);
    }

    #training-dataset-button.expanded .expand-arrow {
      transform: rotate(180deg);
    }

    .expand-arrow {
      transition: transform 0.3s ease;
      margin-left: 8px;
    }

    /* 훈련 누출 버튼들 */
    #training-leak-buttons {
      position: absolute;
      top: 80px; /* Increased spacing to prevent overlap with two-line text */
      left: 20px; /* 훈련 데이터셋 버튼과 정렬 */
      z-index: 10000;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px; /* Slightly increased gap for better spacing */
      max-width: 280px; /* Increased width to accommodate better layout */
      opacity: 1;
      visibility: visible;
      transition: all 0.3s ease;
    }

    #training-leak-buttons.hidden {
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
    }

    #training-leak-buttons button {
      padding: 10px 12px; /* Increased vertical padding for two-line text */
      font-size: 0.75rem;
      font-weight: 600;
      color: #6f42c1;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #6f42c1;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      position: relative;
      line-height: 1.3; /* Better line height for two-line text */
      text-align: center;
      min-height: 40px; /* Ensure consistent height for all buttons */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #training-leak-buttons button:hover {
      background: rgba(111, 66, 193, 0.1);
      box-shadow: 0 6px 16px rgba(111, 66, 193, 0.2);
      transform: translateY(-1px);
    }

    #training-leak-buttons button.active {
      background: linear-gradient(135deg, #6f42c1 0%, #5a2d91 100%);
      color: white;
      border-color: #5a2d91;
      box-shadow: 0 6px 16px rgba(111, 66, 193, 0.4);
    }

    #training-leak-buttons button.active::before {
      content: "●";
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      color: #00ff88;
      font-size: 6px;
      animation: pulse 2s infinite;
    }

    #overlay-buttons {
      position: absolute;
      top: 200px; /* Increased to accommodate larger training leak buttons spacing */
      left: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 200px;
    }

    #overlay-buttons button {
      padding: 10px 15px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #007bff;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #007bff;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      min-width: 120px;
      position: relative;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #overlay-buttons button:hover {
      background: rgba(0, 123, 255, 0.1);
      box-shadow: 0 6px 16px rgba(0, 123, 255, 0.2);
      transform: translateY(-1px);
    }

    /* Active state for running functions */
    #overlay-buttons button.active {
      background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
      color: white;
      border-color: #0056b3;
      box-shadow: 0 0 15px rgba(0, 123, 255, 0.4);
    }

    #overlay-buttons button.active::before {
      content: "●";
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #00ff88;
      font-size: 8px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .hidden {
      opacity: 0 !important;
      visibility: hidden !important;
      transform: translateY(-10px) !important;
    }

    /* Modern Toggle Switch */
    .toggle-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 15px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      height: 40px;
    }

    .toggle-label {
      font-size: 0.85rem;
      font-weight: 500;
      color: #495057;
    }

    .toggle-switch {
      position: relative;
      width: 50px;
      height: 24px;
      background: #dee2e6;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .toggle-switch.active {
      background: #007bff;
    }

    /* Guide Button */
    #guide-button {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10000;
      width: 85px;
      height: 40px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid #007bff;
      border-radius: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      font-weight: bold;
      color: #007bff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }

    #guide-button:hover {
      background: rgba(0, 123, 255, 0.1);
      box-shadow: 0 0 20px rgba(0, 123, 255, 0.3);
      transform: translateY(-1px) scale(1.05);
    }

    #guide-button.active {
      background: rgba(255, 255, 255, 0.95) !important;
      border-color: #007bff;
      box-shadow: 0 0 15px rgba(0, 123, 255, 0.4);
    }

    #guide-button.active::before {
      content: "●";
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #00ff88;
      font-size: 8px;
      animation: pulse 2s infinite;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(26px);
    }

    #popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(248, 249, 250, 0.95);
      border: 1px solid rgba(108, 117, 125, 0.3);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      font-size: 13px;
      z-index: 9999;
      width: 600px;
      max-width: 90vw;
      height: 450px;
      max-height: 80vh;
      overflow: hidden;
      box-sizing: border-box;
      
      /* Animation properties - Only for show/hide, not for dragging */
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
    }

    /* Disable transitions during dragging for smooth movement */
    #popup.dragging {
      transition: none !important;
    }

    #popup.show {
      opacity: 1;
      visibility: visible;
      transform: translate(-50%, -50%) scale(1);
    }

    /* Sensor status indicator animation */
    .sensor-status-indicator {
      animation: sensorPulse 2s ease-in-out infinite;
    }

    @keyframes sensorPulse {
      0% {
        opacity: 1;
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(52, 199, 89, 0.7);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.1);
        box-shadow: 0 0 0 4px rgba(52, 199, 89, 0.3);
      }
      100% {
        opacity: 1;
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(52, 199, 89, 0);
      }
    }

    #popup-header {
      cursor: grab;
      cursor: -webkit-grab;
      padding: 10px 15px;
      border-bottom: 1px solid rgba(108, 117, 125, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 16px 16px 0 0;
      color: #007bff;
      font-weight: 600;
      font-size: 0.95em;
      height: 40px;
      box-sizing: border-box;
      flex-shrink: 0;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    
    #popup-header:active {
      cursor: grabbing;
      cursor: -webkit-grabbing;
    }
    
    #popup-header:active {
      cursor: grabbing;
      cursor: -webkit-grabbing;
    }

    #popup-content {
      width: 100%;
      padding: 15px;
      margin: 0;
      height: calc(100% - 40px);
      overflow-y: auto;
      overflow-x: hidden;
      color: #343a40;
      box-sizing: border-box;
    }

    /* Enhanced chart container styling for proper aspect ratio maintenance */
    #popup-content canvas {
      max-width: 100%;
      max-height: 100%;
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      object-fit: contain; /* Maintain aspect ratio */
    }

    /* Responsive chart containers */
    .chart-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #popup-content canvas {
      max-width: 100%;
      max-height: 100%;
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      border: 1px solid rgba(0, 123, 255, 0.1);
    }

    #closeButton {
      background: transparent;
      color: #007bff;
      border: 1px solid #007bff;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 14px;
      line-height: 22px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      /* Enhanced mobile touch target */
      min-width: 32px;
      min-height: 32px;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      /* Prevent accidental drag */
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      /* Higher z-index to ensure it's always clickable */
      position: relative;
      z-index: 10001;
    }

    #closeButton:hover {
      background: rgba(0, 123, 255, 0.1);
      color: #0056b3;
    }

    #closeButton:active {
      background: rgba(0, 123, 255, 0.2);
      transform: scale(0.95);
    } 

    /* Neural network animation canvas */
    #networkCanvas {
      width: 100%;
      height: 350px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 16px;
      margin-top: 10px;
      border: 1px solid #dee2e6;
      cursor: grab;
      transition: all 0.3s ease;
    }

    #networkCanvas:active {
      cursor: grabbing;
    }

    .network-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }

    .network-controls button {
      padding: 6px 12px;
      font-size: 0.8rem;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .network-controls button:hover {
      background: #0056b3;
      transform: translateY(-1px);
    }

    /* Sensor Labels */
    .sensor-label {
      color: #495057;
      background-color: rgba(255, 255, 255, 0.85);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      position: absolute;
      transform: translateX(-50%) translateY(-160%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(0, 123, 255, 0.3);
      z-index: 1;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .sensor-label.fade-in {
      animation: fadeInLabel 0.2s ease forwards;
    }

    .sensor-label.fade-out {
      animation: fadeOutLabel 0.3s ease-in-out forwards;
    }

    /* Keyframe animations for sensor labels */
    @keyframes fadeInLabel {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(-160%) scale(0.8);
      }
      100% {
        opacity: 1;
        transform: translateX(-50%) translateY(-160%) scale(1);
      }
    }

    @keyframes fadeOutLabel {
      0% {
        opacity: 1;
        transform: translateX(-50%) translateY(-160%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-160%) scale(0.8);
      }
    }

    /* Mobile Sidebar */
    .mobile-sidebar {
      position: fixed;
      top: 0;
      left: -300px;
      width: 280px;
      height: 100vh;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 2px 0 20px rgba(0, 0, 0, 0.1);
      transition: left 0.25s ease-out;
      z-index: 15000;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      border-radius: 0 16px 16px 0;
    }

    .mobile-sidebar.open {
      left: 0;
    }

    .mobile-sidebar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.3);
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 14000;
    }

    .mobile-sidebar-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(0, 123, 255, 0.2);
    }

    .sidebar-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: #007bff;
    }

    .sidebar-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: #666;
      cursor: pointer;
      padding: 5px;
      border-radius: 50%;
      width: 35px;
      height: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .sidebar-close:hover {
      background: rgba(0, 123, 255, 0.1);
      color: #007bff;
    }

    .sidebar-section {
      margin-bottom: 25px;
    }

    .sidebar-section-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #495057;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar-button {
      width: 100%;
      padding: 15px 20px;
      margin-bottom: 10px;
      font-size: 0.95rem;
      font-weight: 500;
      color: #007bff;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #007bff;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
    }

    .sidebar-button:hover, .sidebar-button:active {
      background: rgba(0, 123, 255, 0.1);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.2);
    }

    /* Active state for sidebar main function buttons */
    .sidebar-button.active {
      background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
      color: white;
      border-color: #0056b3;
      box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
    }

    .sidebar-button.active::before {
      content: "●";
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      color: #00ff88;
      font-size: 8px;
      animation: pulse 2s infinite;
    }

    /* Better touch feedback for mobile */
    @media (hover: none) and (pointer: coarse) {
      .sidebar-button:active {
        background: rgba(0, 123, 255, 0.2);
        transform: scale(0.98);
      }
      
      .sidebar-leak-button:active {
        background: rgba(220, 53, 69, 0.2);
        transform: scale(0.98);
      }
      
      .mobile-menu-toggle:active {
        transform: scale(0.95);
      }
    }

    .sidebar-leak-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }

    .sidebar-leak-button {
      padding: 12px;
      font-size: 0.85rem;
      font-weight: 500;
      color: #dc3545;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #dc3545;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      position: relative;
    }

    .sidebar-leak-button:hover, .sidebar-leak-button:active {
      background: rgba(220, 53, 69, 0.1);
      transform: translateY(-1px);
    }

    /* Active state for sidebar leak buttons */
    .sidebar-leak-button.active {
      background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
      color: white;
      border-color: #c82333;
      box-shadow: 0 0 12px rgba(220, 53, 69, 0.3);
    }

    .sidebar-leak-button.active::before {
      content: "●";
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #00ff88;
      font-size: 6px;
      animation: pulse 2s infinite;
    }

    /* 사이드바의 훈련 누출 버튼들 */
    .training-leak-button {
      color: #6f42c1 !important;
      border-color: #6f42c1 !important;
    }

    .training-leak-button:hover, .training-leak-button:active {
      background: rgba(111, 66, 193, 0.1) !important;
      transform: translateY(-1px);
    }

    /* Hamburger Menu */
    .mobile-menu-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 16000;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid #007bff;
      border-radius: 50%;
      cursor: pointer;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    .mobile-menu-toggle:hover {
      background: rgba(0, 123, 255, 0.1);
      transform: scale(1.05);
    }

    .hamburger-line {
      width: 20px;
      height: 2px;
      background: #007bff;
      transition: all 0.3s ease;
      border-radius: 1px;
    }

    .mobile-menu-toggle.active .hamburger-line:nth-child(1) {
      transform: rotate(45deg) translate(5px, 5px);
    }

    .mobile-menu-toggle.active .hamburger-line:nth-child(2) {
      opacity: 0;
    }

    .mobile-menu-toggle.active .hamburger-line:nth-child(3) {
      transform: rotate(-45deg) translate(7px, -6px);
    }

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      /* Hide desktop buttons and show mobile menu */
      #overlay-buttons,
      #training-dataset-button,
      #training-leak-buttons {
        display: none !important;
      }

      .mobile-menu-toggle {
        display: flex;
      }

      .toggle-container {
        bottom: calc(15vh + env(safe-area-inset-bottom, 20px)); /* Responsive bottom position with safe area */
        right: 15px;
        left: auto;
        top: auto;
        height: 50px; /* Match hamburger button height */
        align-items: center;
        z-index: 15000; /* Higher than mobile menu */
        /* Enhanced mobile browser UI compatibility */
        min-height: 50px;
        box-sizing: border-box;
      }

      #guide-button {
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        font-size: 1.2rem;
        border-radius: 50%;
      }

      /* Mobile project title */
      .project-title {
        top: 15px;
        padding: 12px 24px;
        max-width: calc(100vw - 140px); /* Account for hamburger and guide buttons */
      }

      .project-title-main {
        font-size: 1.1rem;
      }

      .project-title-subtitle {
        font-size: 0.65rem;
      }

      .project-title-icon {
        font-size: 1.2em;
      }

      /* Hide text on mobile, show only emoji */
      #guide-button .guide-text {
        display: none;
      }

      /* Enhanced mobile popup styles - Different sizes for different popup types */
      #popup:not(.guide-popup) {
        width: 90vw !important;
        height: 40vh !important; /* Increased from 35vh to accommodate better chart aspect ratios */
        max-width: 90vw !important;
        max-height: 40vh !important;
        bottom: 5vw !important;
        right: 5vw !important;
        top: auto !important;
        left: auto !important;
        transform: none !important;
        border-radius: 16px;
        font-size: 14px;
      }

      /* Guide popup gets larger size on mobile */
      #popup.guide-popup {
        width: 90vw !important;
        height: 67vh !important; /* 2/3 of screen height for guide popup */
        max-width: 90vw !important;
        max-height: 67vh !important;
        top: 50% !important;
        left: 50% !important;
        bottom: auto !important;
        right: auto !important;
        transform: translate(-50%, -50%) !important;
        border-radius: 16px;
        font-size: 14px;
      }

      /* Learning popup gets centered with 1/2 screen height */
      #popup.learning-popup {
        width: 90vw !important;
        height: 50vh !important; /* 1/2 of screen height for learning popup */
        max-width: 90vw !important;
        max-height: 50vh !important;
        top: 50% !important;
        left: 50% !important;
        bottom: auto !important;
        right: auto !important;
        transform: translate(-50%, -50%) !important;
        border-radius: 16px;
        font-size: 14px;
      }

      #popup-header {
        padding: 12px 15px;
        font-size: 0.9rem;
        height: 45px;
        /* Enable dragging on mobile with visual feedback */
        cursor: grab !important;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        /* Add subtle background to indicate draggable area */
        background: rgba(0, 123, 255, 0.05);
        border-bottom: 1px solid rgba(0, 123, 255, 0.1);
      }
      
      #popup-header:active {
        cursor: grabbing !important;
        background: rgba(0, 123, 255, 0.1);
      }

      #popup-content {
        height: calc(100% - 45px);
        padding: 12px;
        font-size: 0.85rem;
      }

      /* Enhanced close button for mobile */
      #closeButton {
        min-width: 40px !important;
        min-height: 40px !important;
        width: 40px !important;
        height: 40px !important;
        font-size: 16px !important;
        border-width: 2px !important;
        /* Better touch target */
        position: relative;
        z-index: 10001;
      }

      /* Neural network canvas mobile optimization - flexible responsive approach */
      #networkCanvas {
        width: 100% !important;
        height: auto !important; /* Let aspect ratio determine height */
        min-height: 200px !important; /* Minimum height for usability */
        max-height: 30vh !important; /* Maximum based on viewport for mobile */
      }

      /* Chart optimization for mobile - flexible responsive approach */
      #leakChart {
        width: 100% !important;
        height: auto !important; /* Let aspect ratio determine height */
        min-height: 200px !important; /* Minimum height for usability */
        max-height: 30vh !important; /* Maximum based on viewport for mobile */
      }

      .sensor-label {
        font-size: 9px;
        padding: 2px 5px;
      }

      /* Better touch targets for mobile */
      .sidebar-button {
        min-height: 50px;
      }

      .sidebar-leak-button {
        min-height: 45px;
      }
    }

    @media (max-width: 480px) {
      .mobile-sidebar {
        width: 90vw;
        left: -90vw;
      }

      #popup {
        width: 95vw !important;
        height: 35vh !important; /* Increased from 30vh for better chart visibility */
        bottom: 2.5vw !important;
        right: 2.5vw !important;
        border-radius: 16px;
        font-size: 13px;
      }

      /* Guide popup for very small screens */
      #popup.guide-popup {
        width: 95vw !important;
        height: 70vh !important;
        top: 50% !important;
        left: 50% !important;
        bottom: auto !important;
        right: auto !important;
        transform: translate(-50%, -50%) !important;
      }

      /* Learning popup for very small screens */
      #popup.learning-popup {
        width: 95vw !important;
        height: 45vh !important; /* Slightly smaller on very small screens */
        top: 50% !important;
        left: 50% !important;
        bottom: auto !important;
        right: auto !important;
        transform: translate(-50%, -50%) !important;
      }

      #popup-header {
        font-size: 0.85rem;
        height: 40px;
        padding: 10px 12px;
      }

      #popup-content {
        height: calc(100% - 40px);
        padding: 10px;
        font-size: 0.8rem;
      }

      #networkCanvas {
        width: 100% !important;
        height: auto !important; /* Flexible height based on aspect ratio */
        min-height: 180px !important; /* Minimum for very small screens */
        max-height: 25vh !important; /* Responsive maximum */
      }

      #leakChart {
        width: 100% !important;
        height: auto !important; /* Flexible height based on aspect ratio */
        min-height: 180px !important; /* Minimum for very small screens */
        max-height: 25vh !important; /* Responsive maximum */
      }

      .mobile-menu-toggle {
        width: 45px;
        height: 45px;
        top: 15px;
        left: 15px;
      }

      .toggle-container {
        bottom: calc(15vh + env(safe-area-inset-bottom, 20px)); /* Responsive positioning for mobile browsers */
        right: 15px;
        left: auto;
        top: auto;
        height: 45px; /* Match hamburger button height */
        align-items: center;
        /* Enhanced mobile browser compatibility */
        min-height: 45px;
        box-sizing: border-box;
        z-index: 1000;
      }

      #guide-button {
        width: 45px;
        height: 45px;
        top: 15px;
        right: 15px;
        font-size: 1.1rem;
      }

      /* Very small mobile project title */
      .project-title {
        top: 10px;
        padding: 10px 20px;
        max-width: calc(100vw - 120px); /* Account for smaller buttons */
      }

      .project-title-main {
        font-size: 0.95rem;
      }

      .project-title-subtitle {
        font-size: 0.6rem;
      }

      .project-title-icon {
        font-size: 1.1em;
      }
    }

    /* Landscape orientation adjustments for mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      .mobile-sidebar {
        width: 320px;
        left: -320px;
      }
      
      #popup {
        width: 80vw !important;
        height: 85vh !important;
        bottom: 7.5vh !important;
        right: 10vw !important;
      }
      
      .sidebar-section {
        margin-bottom: 20px;
      }
    }
  </style>
</head>

<body>
  <!-- Project Title -->
  <div class="project-title">
    <div class="project-title-main">
      AI 누출원 탐지 Mockup
    </div>
  </div>

  <div class="container">
    <div class="right-panel" id="viewer"></div>
  </div>

  <!-- Mobile Menu Toggle -->
  <div class="mobile-menu-toggle" id="mobile-menu-toggle" onclick="toggleMobileSidebar()">
    <div class="hamburger-line"></div>
    <div class="hamburger-line"></div>
    <div class="hamburger-line"></div>
  </div>

  <!-- Mobile Sidebar -->
  <div class="mobile-sidebar-overlay" id="mobile-sidebar-overlay" onclick="closeMobileSidebar()"></div>
  <div class="mobile-sidebar" id="mobile-sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">메뉴</div>
      <button class="sidebar-close" onclick="closeMobileSidebar()">✖</button>
    </div>
    
    <div class="sidebar-section">
      <div class="sidebar-section-title">훈련 데이터셋</div>
      <div class="sidebar-leak-buttons">
        <button id="sidebar-leak-1-btn" class="sidebar-leak-button training-leak-button" onclick="showLeakData(1); closeMobileSidebar();">훈련 누출 #1</button>
        <button id="sidebar-leak-2-btn" class="sidebar-leak-button training-leak-button" onclick="showLeakData(2); closeMobileSidebar();">훈련 누출 #2</button>
        <button id="sidebar-leak-3-btn" class="sidebar-leak-button training-leak-button" onclick="showLeakData(3); closeMobileSidebar();">훈련 누출 #3</button>
        <button id="sidebar-leak-4-btn" class="sidebar-leak-button training-leak-button" onclick="showLeakData(4); closeMobileSidebar();">훈련 누출 #4</button>
        <button id="sidebar-leak-5-btn" class="sidebar-leak-button training-leak-button" onclick="showLeakData(5); closeMobileSidebar();">훈련 누출 #5</button>
        <button id="sidebar-leak-6-btn" class="sidebar-leak-button training-leak-button" onclick="showLeakData(6); closeMobileSidebar();">훈련 누출 #6</button>
      </div>
    </div>
    
    <div class="sidebar-section">
      <div class="sidebar-section-title">주요 기능</div>
      <button id="sidebar-learning-btn" class="sidebar-button" onclick="LearningStart(); closeMobileSidebar();">
        🤖 AI 신경망 학습
      </button>
      <button id="sidebar-detection-btn" class="sidebar-button" onclick="LeakDetection(); closeMobileSidebar();">
        🔍 AI 기반 누출 탐지
      </button>
      <button id="sidebar-dispersion-btn" class="sidebar-button" onclick="Dispersion(); closeMobileSidebar();">
        🌊 암모니아 확산 양상
      </button>
    </div>
  </div>

  <button id="training-dataset-button" onclick="toggleTrainingDataset()" title="훈련 데이터셋">
    📊 훈련 데이터셋 <span class="expand-arrow">▼</span>
  </button>
  
  <div id="training-leak-buttons" class="training-buttons hidden">
    <button id="leak-1-btn" onclick="showLeakData(1)">훈련 누출 #1</button>
    <button id="leak-2-btn" onclick="showLeakData(2)">훈련 누출 #2</button>
    <button id="leak-3-btn" onclick="showLeakData(3)">훈련 누출 #3</button>
    <button id="leak-4-btn" onclick="showLeakData(4)">훈련 누출 #4</button>
    <button id="leak-5-btn" onclick="showLeakData(5)">훈련 누출 #5</button>
    <button id="leak-6-btn" onclick="showLeakData(6)">훈련 누출 #6</button>
  </div>

  <div id="overlay-buttons">
    <button id="learning-btn" onclick="LearningStart()">🤖 AI 신경망 학습</button>
    <button id="detection-btn" onclick="LeakDetection()">🔍 AI 기반 누출 탐지</button>
    <button id="dispersion-btn" onclick="Dispersion()">🌊 암모니아 확산 양상</button>
  </div>

  <div id="guide-button" onclick="toggleGuide()" title="사용법 가이드">
    💡<span class="guide-text"> 가이드</span>
  </div>

  <div class="toggle-container">
    <span class="toggle-label">Sensor Labels</span>
    <div class="toggle-switch active" id="toggle-switch" onclick="toggleLabels()">
      <div class="toggle-slider"></div>
    </div>
  </div>

  <div id="popup">
    <div id="popup-header">
      <span id="popupTitle">정보</span>
      <button id="closeButton" onclick="closePopup()" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">✖</button>
    </div>
    <div id="popup-content"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    let scene, camera, renderer, loader, controls, currentModel;
    const popup = document.getElementById('popup');
    const popupHeader = document.getElementById('popup-header');
    const popupTitleElement = document.getElementById('popupTitle');
    let popupLocked = true;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let INTERSECTED = null;

    if (!window.clickableCubes) window.clickableCubes = [];
    
    const sensorLabels = [];
    const sensorObjects = {};
    let labelsVisible = true;

    let leakChart;
    let leakTimer;
    let leakData = [];
    let leakIndex = 0;
    const CHART_SPEED_FACTOR = 25; // Increased speed factor

    // Stored chart data for reopening popups
    const storedChartData = {};

    // Toggle states for different functions
    const toggleStates = {
      guide: false,
      learning: false,
      detection: false,
      dispersion: false,
      leak1: false,
      leak2: false,
      leak3: false,
      leak4: false,
      leak5: false,
      leak6: false
    };

    // Neural network variables
    let networkScale = 1;
    let networkCanvas = null;
    let networkCtx = null;

    // Device detection
    const isMobileDevice = () => {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             window.innerWidth <= 768 || 
             ('ontouchstart' in window);
    };

    // Mobile sidebar state
    let sidebarOpen = false;
    
    // Dispersion variables
    let dispersionGroup = new THREE.Group();
    let isDispersionActive = false;

    // Function to update button active states based on toggleStates
    function updateButtonStates() {
      // Desktop buttons
      const desktopButtons = {
        learning: document.getElementById('learning-btn'),
        detection: document.getElementById('detection-btn'),
        dispersion: document.getElementById('dispersion-btn'),
        leak1: document.getElementById('leak-1-btn'),
        leak2: document.getElementById('leak-2-btn'),
        leak3: document.getElementById('leak-3-btn'),
        leak4: document.getElementById('leak-4-btn'),
        leak5: document.getElementById('leak-5-btn'),
        leak6: document.getElementById('leak-6-btn')
      };

      // Mobile buttons
      const mobileButtons = {
        learning: document.getElementById('sidebar-learning-btn'),
        detection: document.getElementById('sidebar-detection-btn'),
        dispersion: document.getElementById('sidebar-dispersion-btn'),
        leak1: document.getElementById('sidebar-leak-1-btn'),
        leak2: document.getElementById('sidebar-leak-2-btn'),
        leak3: document.getElementById('sidebar-leak-3-btn'),
        leak4: document.getElementById('sidebar-leak-4-btn'),
        leak5: document.getElementById('sidebar-leak-5-btn'),
        leak6: document.getElementById('sidebar-leak-6-btn')
      };

      // Update desktop buttons
      Object.keys(desktopButtons).forEach(key => {
        const button = desktopButtons[key];
        if (button) {
          if (toggleStates[key]) {
            button.classList.add('active');
          } else {
            button.classList.remove('active');
          }
        }
      });

      // Update mobile buttons  
      Object.keys(mobileButtons).forEach(key => {
        const button = mobileButtons[key];
        if (button) {
          if (toggleStates[key]) {
            button.classList.add('active');
          } else {
            button.classList.remove('active');
          }
        }
      });

      // Update guide button
      const guideButton = document.getElementById('guide-button');
      if (guideButton) {
        if (toggleStates.guide) {
          guideButton.classList.add('active');
        } else {
          guideButton.classList.remove('active');
        }
      }
    }

    init();
    loadModel('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/model_GE-v1.glb');
    
    // Initialize mobile features after page load
    document.addEventListener('DOMContentLoaded', () => {
      initializeMobileFeatures();
    });
    
    // Also initialize if already loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeMobileFeatures);
    } else {
      initializeMobileFeatures();
    }

    function init() {
      const container = document.getElementById('viewer');
      scene = new THREE.Scene();
      scene.add(dispersionGroup);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      scene.background = new THREE.Color(0xddeeff);
      container.appendChild(renderer.domElement);

      const aspect = container.clientWidth / container.clientHeight;
      const dist = 15;
      camera = new THREE.OrthographicCamera(-dist * aspect, dist * aspect, dist, -dist, 0.1, 1000);
      camera.position.set(15, 10, 15); // Changed viewport direction for better mobile viewing angle
      camera.lookAt(0, 0, 0);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 5;
      controls.maxDistance = 100;
      // Remove maxPolarAngle limit to allow full rotation
      controls.update();

      loader = new THREE.GLTFLoader();

      scene.add(new THREE.AmbientLight(0x777777, 0.5));
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(8, 15, 10);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const keyLight = new THREE.PointLight(0xffffff, 0.3, 150);
      keyLight.position.set(-15, 20, 15);
      scene.add(keyLight);

      const fillLight = new THREE.PointLight(0xaaaaff, 0.15, 100);
      fillLight.position.set(15, 5, -15);
      scene.add(fillLight);
      
      // Add sensors and leak points
      addLabeledSensor(3.45, 1.11, -0.565, 'Sensor #1', 0.5);
      addLabeledSensor(-0.507, 1.11, -0.565, 'Sensor #2', 0.5);
      addLabeledSensor(-4.46, 1.11, -0.565, 'Sensor #3', 0.5);
      addLabeledSensor(4.26, 1.11, 0.360, 'Sensor #4', 0.5);
      addLabeledSensor(0.304, 1.11, 0.360, 'Sensor #5', 0.5);
      addLabeledSensor(-3.65, 1.11, 0.360, 'Sensor #6', 0.5);
      
      addLeakPoint(3.0, 3.0, -1.0, 'Leak #1', 0.2);
      addLeakPoint(-0.9, 3.0, -1.0, 'Leak #2', 0.2);
      addLeakPoint(-4.8, 3.0, -1.0, 'Leak #3', 0.2);
      addLeakPoint(4.5, -1.5, 2.0, 'Leak #4', 0.2);
      addLeakPoint(0.6, -1.5, 2.0, 'Leak #5', 0.2);
      addLeakPoint(-3.3, -1.5, 2.0, 'Leak #6', 0.2);
      addLeakPoint(4.5, 0.0, 2.0, 'Leak #7', 0.2);
      
      animate();
      setupEventListeners();
    }

    function loadModel(path) {
      if (currentModel) {
        scene.remove(currentModel);
        currentModel.traverse(child => {
          if (child.isMesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(mat => mat.dispose());
              } else {
                child.material.dispose();
              }
            }
          }
        });
        currentModel = null;
      }

      loader.load(path, function (gltf) {
        currentModel = gltf.scene;
        scene.add(currentModel);
      }, undefined, function (error) {
        console.error('모델 로드 실패:', error);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      updateSensorLabels();
      renderer.render(scene, camera);
    }

    // Enhanced sensor creation with better styling
    function addLabeledSensor(x, y, z, name, size = 0.5) {
      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshStandardMaterial({
        color: 0x007bff,
        emissive: 0x004499,
        emissiveIntensity: 0.2,
        transparent: true,
        opacity: 0.7
      });

      const sensor = new THREE.Mesh(geometry, material);
      sensor.position.set(x, y, z);
      sensor.userData.name = name;
      sensor.userData.originalColor = 0x007bff;
      sensor.userData.type = 'sensor';
      sensor.userData.position = { x, y, z };
      sensor.userData.specifications = {
        model: 'NH₃-SENSOR-V2.1',
        range: '0-100 ppm',
        accuracy: '±2% F.S.',
        response: '< 30 seconds',
        power: '12-24V DC'
      };
      scene.add(sensor);
      sensorObjects[name] = sensor;
      window.clickableCubes.push(sensor);

      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';
      labelDiv.textContent = name;
      labelDiv.style.cursor = 'pointer';
      labelDiv.addEventListener('click', (e) => {
        e.stopPropagation();
        showSensorInfo(sensor);
      });
      document.body.appendChild(labelDiv);
      sensorLabels.push({mesh: sensor, div: labelDiv});
    }

    // Enhanced leak point creation
    function addLeakPoint(x, y, z, name, size = 0.2) {
      const geometry = new THREE.SphereGeometry(size, 16, 16);
      const material = new THREE.MeshStandardMaterial({
        color: 0xdc3545,
        emissive: 0xaa2230,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.85
      });

      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(x, y, z);
      sphere.userData.name = name;
      sphere.userData.leakNumber = parseInt(name.split('#')[1]);
      sphere.userData.originalColor = 0xdc3545;
      sphere.userData.type = 'leak';
      scene.add(sphere);

      window.clickableCubes.push(sphere);

      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';
      labelDiv.textContent = name;
      labelDiv.style.color = '#dc3545';
      labelDiv.style.borderColor = 'rgba(220, 53, 69, 0.4)';
      labelDiv.style.cursor = 'pointer';
      labelDiv.addEventListener('click', (e) => {
        e.stopPropagation();
        const leakNumber = sphere.userData.leakNumber;
        if (leakNumber === 7) {
          // For Leak #7, call LeakDetection instead of showLeakData
          toggleStates.detection = false; // Reset first to ensure proper toggle
          updateButtonStates(); // Update UI to reflect the state
          LeakDetection(); // This will properly activate AI-based detection
        } else {
          showLeakData(leakNumber);
        }
      });
      document.body.appendChild(labelDiv);
      sensorLabels.push({mesh: sphere, div: labelDiv});
    }

    function updateSensorLabels() {
      sensorLabels.forEach(({mesh, div}) => {
        if (!labelsVisible) {
          // Don't modify display if fade-out animation is in progress
          if (!div.classList.contains('fade-out')) {
            div.style.display = 'none';
          }
          return;
        }

        // Ensure label is visible when labels are enabled
        if (labelsVisible && div.style.display === 'none') {
          div.style.display = 'block';
        }

        const vector = mesh.position.clone();
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

        div.style.left = x + 'px';
        div.style.top = y + 'px';

        // Enhanced visibility check for mobile compatibility
        // Use more lenient bounds and distance calculation
        const distance = camera.position.distanceTo(mesh.position);
        const isVisible = vector.z > -1 && vector.z < 1 && 
                         x >= -50 && x <= window.innerWidth + 50 && 
                         y >= -50 && y <= window.innerHeight + 50 &&
                         distance < controls.maxDistance * 1.2; // More lenient distance check

        if (!isVisible) {
          div.style.opacity = '0';
          div.style.pointerEvents = 'none'; // Disable interactions when not visible
        } else if (labelsVisible) {
          // Restore opacity and interactions for visible labels (unless fade-out is active)
          if (!div.classList.contains('fade-out')) {
            div.style.opacity = '';
            div.style.pointerEvents = 'auto'; // Re-enable interactions
          }
        }
      });
    }

    function toggleLabels() {
      labelsVisible = !labelsVisible;
      const toggleSwitch = document.getElementById('toggle-switch');
      
      if (labelsVisible) {
        toggleSwitch.classList.add('active');
        // Show labels with fade-in animation
        sensorLabels.forEach(({div}) => {
          div.classList.remove('fade-out');
          div.style.display = 'block';
          // Use requestAnimationFrame to ensure the display change is applied before adding fade-in class
          requestAnimationFrame(() => {
            div.classList.add('fade-in');
          });
        });
      } else {
        toggleSwitch.classList.remove('active');
        // Hide labels with fade-out animation
        sensorLabels.forEach(({div}) => {
          div.classList.remove('fade-in');
          div.classList.add('fade-out');
          // Hide after animation completes
          setTimeout(() => {
            if (!labelsVisible) {
              div.style.display = 'none';
            }
          }, 300); // Match CSS transition duration
        });
      }
      updateSensorLabels();
    }

    // AI Learning with interactive neural network visualization
    async function LearningStart() {
      if (toggleStates.learning) {
        closePopup();
        toggleStates.learning = false;
        updateButtonStates();
        return;
      }
      
      // Ensure clean state before proceeding
      await ensureCleanState();
      
      // Reset other toggles
      Object.keys(toggleStates).forEach(key => toggleStates[key] = false);
      toggleStates.learning = true;
      updateButtonStates();
      
      popupLocked = true;
      popupTitleElement.textContent = "AI 학습 - 신경망 시각화";
      
      const html = `
        <div style="text-align: center; padding: 10px;">
          <div class="chart-container" style="height: 350px;">
            <canvas id="networkCanvas" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; border: 1px solid #dee2e6; cursor: grab; position: relative;"></canvas>
          </div>
          <div style="margin-top: 15px; padding: 10px; background: rgba(0, 123, 255, 0.1); border-radius: 8px;">
            <p style="margin: 5px 0; font-size: 1.1em; color: #333; font-weight: 600;">딥러닝 신경망 학습 진행 중...</p>
            <p style="margin: 5px 0; font-size: 0.9em; color: #555;">복잡한 다층 신경망 구조가 학습 데이터를 처리하고 있습니다.</p>
            <p style="margin: 5px 0; font-size: 0.8em; color: #777;">마우스 휠로 확대/축소, 드래그로 이동 가능</p>
          </div>
        </div>
      `;

      document.getElementById('popup-content').innerHTML = html;
      
      if (isMobileDevice()) {
        adjustPopupForMobile('learning'); // Use 'learning' type for neural network popup
      } else {
        popup.style.width = '520px';
        popup.style.maxWidth = '90vw';
        popup.style.height = '480px';
        popup.style.maxHeight = '80vh';
        popup.style.bottom = 'auto';
        popup.style.right = 'auto';
        popup.style.top = '50%';
        popup.style.left = '50%';
        // Preserve any existing drag position
        preservePopupPosition();
        popup.style.background = 'rgba(248, 249, 250, 0.95)';
      }
      
      // Show popup with animation
      popup.classList.add('show');
      
      setTimeout(initNeuralNetworkAnimation, 100);
    }

    function adjustNetworkScale(factor) {
      networkScale *= factor;
      networkScale = Math.max(0.3, Math.min(3, networkScale));
    }

    function resetNetworkScale() {
      networkScale = 1;
    }

    function initNeuralNetworkAnimation() {
      networkCanvas = document.getElementById('networkCanvas');
      if (!networkCanvas) return;
      
      networkCtx = networkCanvas.getContext('2d');
      networkCanvas.width = networkCanvas.clientWidth;
      networkCanvas.height = networkCanvas.clientHeight;
      
      const layers = [3, 6, 18, 18, 6, 3];
      let neurons = [];
      let connections = [];
      
      let offsetX = 0, offsetY = 0;
      let isDragging = false;
      
      // Add Reset View button to canvas
      const canvasContainer = networkCanvas.parentElement;
      const resetButton = document.createElement('button');
      resetButton.innerHTML = 'Reset View';
      resetButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        font-size: 0.8rem;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        z-index: 10;
        transition: all 0.3s ease;
      `;
      resetButton.onmouseover = function() { this.style.background = '#0056b3'; };
      resetButton.onmouseout = function() { this.style.background = '#007bff'; };
      resetButton.onclick = function() {
        networkScale = 1;
        offsetX = 0;
        offsetY = 0;
      };
      canvasContainer.style.position = 'relative';
      canvasContainer.appendChild(resetButton);
      
      // Interactive controls
      networkCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        adjustNetworkScale(factor);
      });
      
      networkCanvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        const rect = networkCanvas.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
      });
      
      networkCanvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const rect = networkCanvas.getBoundingClientRect();
        const deltaX = (e.clientX - rect.left) - offsetX;
        const deltaY = (e.clientY - rect.top) - offsetY;
        // Apply drag offset
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
      });
      
      networkCanvas.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      function initializeNetwork() {
        neurons = [];
        connections = [];
        
        const padding = Math.min(networkCanvas.width, networkCanvas.height) * 0.1;
        const layerSpacing = (networkCanvas.width - padding * 2) / (layers.length - 1);
        
        // Create neurons
        layers.forEach((neuronCount, layerIndex) => {
          const layerX = padding + layerIndex * layerSpacing;
          const neuronSpacing = (networkCanvas.height - padding * 2) / (neuronCount + 1);
          
          for (let i = 1; i <= neuronCount; i++) {
            const neuronY = padding + i * neuronSpacing;
            neurons.push({
              baseX: layerX,
              baseY: neuronY,
              x: layerX,
              y: neuronY,
              layer: layerIndex,
              index: i,
              baseRadius: Math.min(networkCanvas.width, networkCanvas.height) * 0.01,
              radius: Math.min(networkCanvas.width, networkCanvas.height) * 0.01,
              activation: Math.random(),
              activationTarget: Math.random(),
              speed: 0.01 + Math.random() * 0.03
            });
          }
        });
        
        // Create connections
        for (let l = 0; l < layers.length - 1; l++) {
          const layerNeurons = neurons.filter(n => n.layer === l);
          const nextLayerNeurons = neurons.filter(n => n.layer === l + 1);
          
          layerNeurons.forEach(from => {
            nextLayerNeurons.forEach(to => {
              connections.push({
                from: from,
                to: to,
                weight: Math.random() * 2 - 1,
                signalPosition: 0,
                signalSpeed: 0.01 + Math.random() * 0.02,
                active: Math.random() > 0.7,
                signal: false
              });
            });
          });
        }
      }
      
      function updateNetworkScale() {
        const centerX = networkCanvas.width / 2;
        const centerY = networkCanvas.height / 2;
        
        neurons.forEach(neuron => {
          // Scale position relative to center
          neuron.x = centerX + (neuron.baseX - centerX) * networkScale + offsetX;
          neuron.y = centerY + (neuron.baseY - centerY) * networkScale + offsetY;
          neuron.radius = Math.max(2, neuron.baseRadius * networkScale);
        });
      }
      
      initializeNetwork();
      
      function animateNetwork() {
        updateNetworkScale();
        
        networkCtx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);
        
        // Draw connections with proper scaling
        connections.forEach(conn => {
          if (Math.random() < 0.01) conn.active = Math.random() > 0.3;
          
          if (conn.active) {
            conn.signalPosition += conn.signalSpeed;
            if (conn.signalPosition > 1) {
              conn.signalPosition = 0;
              conn.to.activationTarget = Math.min(1, conn.to.activationTarget + 0.3);
            }
          }
          
          networkCtx.beginPath();
          networkCtx.moveTo(conn.from.x, conn.from.y);
          networkCtx.lineTo(conn.to.x, conn.to.y);
          
          const alpha = conn.active ? 0.3 : 0.05;
          const weight = Math.abs(conn.weight);
          const color = conn.weight > 0 ? `rgba(0, 123, 255, ${alpha})` : `rgba(220, 53, 69, ${alpha})`;
          
          networkCtx.strokeStyle = color;
          networkCtx.lineWidth = Math.max(0.5, weight * 2 * networkScale);
          networkCtx.stroke();
          
          // Enhanced signal visualization with scaling
          if (conn.active) {
            const x = conn.from.x + (conn.to.x - conn.from.x) * conn.signalPosition;
            const y = conn.from.y + (conn.to.y - conn.from.y) * conn.signalPosition;
            
            const gradient = networkCtx.createRadialGradient(x, y, 0, x, y, 4 * networkScale);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            gradient.addColorStop(0.5, 'rgba(0, 123, 255, 0.7)');
            gradient.addColorStop(1, 'rgba(0, 123, 255, 0)');
            
            networkCtx.beginPath();
            networkCtx.arc(x, y, 4 * networkScale, 0, Math.PI * 2);
            networkCtx.fillStyle = gradient;
            networkCtx.fill();
          }
        });
        
        // Draw neurons with proper scaling
        neurons.forEach(neuron => {
          neuron.activation += (neuron.activationTarget - neuron.activation) * neuron.speed;
          if (Math.random() < 0.01) neuron.activationTarget = Math.random();
          
          // Outer glow
          const glowGradient = networkCtx.createRadialGradient(
            neuron.x, neuron.y, 0,
            neuron.x, neuron.y, neuron.radius * 2
          );
          glowGradient.addColorStop(0, `rgba(0, 123, 255, ${neuron.activation * 0.3})`);
          glowGradient.addColorStop(1, 'rgba(0, 123, 255, 0)');
          
          networkCtx.beginPath();
          networkCtx.arc(neuron.x, neuron.y, neuron.radius * 2, 0, Math.PI * 2);
          networkCtx.fillStyle = glowGradient;
          networkCtx.fill();
          
          // Main neuron
          const gradient = networkCtx.createRadialGradient(
            neuron.x - neuron.radius * 0.3, neuron.y - neuron.radius * 0.3, 0,
            neuron.x, neuron.y, neuron.radius
          );
          
          const intensity = Math.floor(neuron.activation * 150) + 105;
          gradient.addColorStop(0, `rgb(${Math.min(255, intensity + 50)}, ${Math.min(255, intensity + 30)}, 255)`);
          gradient.addColorStop(1, `rgb(${Math.max(50, intensity - 20)}, ${Math.max(30, intensity - 40)}, ${Math.max(200, intensity + 20)})`);
          
          networkCtx.beginPath();
          networkCtx.arc(neuron.x, neuron.y, neuron.radius, 0, Math.PI * 2);
          networkCtx.fillStyle = gradient;
          networkCtx.fill();
          
          // Border
          networkCtx.strokeStyle = `rgba(0, 80, 160, 0.8)`;
          networkCtx.lineWidth = 1 * networkScale;
          networkCtx.stroke();
        });
        
        window.neuralNetAnimationId = requestAnimationFrame(animateNetwork);
      }
      
      animateNetwork();
    }

    // Show leak data for specific leak numbers
    async function showLeakData(leakNumber) {
      const leakKey = `leak${leakNumber}`;
      
      if (toggleStates[leakKey]) {
        closePopup();
        toggleStates[leakKey] = false;
        updateButtonStates();
        return;
      }
      
      // Ensure clean state before proceeding
      await ensureCleanState();
      
      // Reset other toggles
      Object.keys(toggleStates).forEach(key => toggleStates[key] = false);
      toggleStates[leakKey] = true;
      updateButtonStates();
      
      const chartKey = `leak_${leakNumber}`;

      popupLocked = false;
      popupTitleElement.textContent = `Leak #${leakNumber} - 센서 데이터`;

      const csvPath = `./sensor_data/scenario_${leakNumber}-1.csv`;
      const backupPath = `https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/sensor_data/scenario_${leakNumber}-1.csv`;

      fetch(csvPath)
        .then(response => {
          if (!response.ok) {
            console.warn(`로컬 파일 로드 실패, 백업 사용: ${backupPath}`);
            return fetch(backupPath);
          }
          return response;
        })
        .catch(() => {
          console.warn(`로컬 파일 접근 실패, 백업 사용: ${backupPath}`);
          return fetch(backupPath);
        })
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          return response.text();
        })
        .then(csvText => {
          processLeakCSVData(csvText, chartKey, leakNumber);
        })
        .catch(error => {
          document.getElementById('popup-content').innerHTML = `<p style="color:red;">CSV 로드 실패: ${error}</p>`;
          showChartPopup();
        });
    }

    function processLeakCSVData(csvText, chartKey, leakNumber) {
      const lines = csvText.trim().split('\n');
      const headers = lines[0].split(',');
      const timeIdx = headers.indexOf('Time (sec)');

      if (timeIdx === -1) {
        throw new Error("'Time (sec)' 컬럼을 찾을 수 없습니다.");
      }

      const valueIndices = headers
        .map((h, i) => ({ name: h.trim(), idx: i }))
        .filter(obj => obj.name !== 'Time (sec)');

      leakData = [];
      for (let i = 1; i < lines.length; i++) {
        const parts = lines[i].split(',');
        const time = parseFloat(parts[timeIdx]);
        const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
        leakData.push({ x: time, yValues: values });
      }

      // Store the data for later use
      storedChartData[chartKey] = {
        data: leakData,
        valueIndices: valueIndices,
        leakNumber: leakNumber
      };

      createLeakChart(valueIndices, leakNumber);
      showChartPopup();
      startLeakAnimation();
    }

    function createLeakChart(valueIndices, leakNumber) {
      document.getElementById('popup-content').innerHTML = `
        <div style="width: 100%; height: 100%; padding: 5px; box-sizing: border-box; display: flex; flex-direction: column;">
          <div style="flex: 1; position: relative; min-height: 0;">
            <canvas id="leakChart" style="width: 100% !important; height: 100% !important; max-width: 100%; max-height: 100%; display: block;"></canvas>
          </div>
        </div>
      `;
      
      const ctx = document.getElementById('leakChart').getContext('2d');
      
      // Apple-inspired color palette
      const colors = [
        { border: '#007AFF', bg: 'rgba(0, 122, 255, 0.1)' },    // Blue
        { border: '#34C759', bg: 'rgba(52, 199, 89, 0.1)' },     // Green  
        { border: '#FF9500', bg: 'rgba(255, 149, 0, 0.1)' },     // Orange
        { border: '#FF3B30', bg: 'rgba(255, 59, 48, 0.1)' },     // Red
        { border: '#AF52DE', bg: 'rgba(175, 82, 222, 0.1)' },    // Purple
        { border: '#5856D6', bg: 'rgba(88, 86, 214, 0.1)' }      // Indigo
      ];
      
      leakChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: valueIndices.map((obj, index) => ({
            label: obj.name,
            data: [],
            borderColor: colors[index % colors.length].border,
            backgroundColor: colors[index % colors.length].bg,
            borderWidth: 2.5,
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            pointHoverRadius: 4,
            pointBackgroundColor: colors[index % colors.length].border,
            pointBorderColor: '#ffffff',
            pointBorderWidth: 2
          }))
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: true, // Enable aspect ratio maintenance
          aspectRatio: 2, // Set a 2:1 ratio (width:height) for mobile-friendly charts
          interaction: {
            intersect: false,
            mode: 'index'
          },
          layout: {
            padding: {
              top: 5,
              bottom: 5,
              left: 5,
              right: 5
            }
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              align: 'start',
              labels: {
                usePointStyle: true,
                padding: 8,
                boxWidth: 8,
                boxHeight: 8,
                font: {
                  family: "'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                  size: 10,
                  weight: '500'
                },
                color: '#1d1d1f'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#ffffff',
              bodyColor: '#ffffff',
              borderColor: 'rgba(255, 255, 255, 0.1)',
              borderWidth: 1,
              cornerRadius: 8,
              displayColors: true,
              titleFont: {
                family: "'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                size: 11,
                weight: '600'
              },
              bodyFont: {
                family: "'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                size: 10
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'Time (s)',
                font: {
                  family: "'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                  size: 11,
                  weight: '600'
                },
                color: '#1d1d1f'
              },
              min: 0,
              grid: {
                color: 'rgba(0, 0, 0, 0.06)',
                lineWidth: 1
              },
              ticks: {
                font: {
                  family: "'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                  size: 9
                },
                color: '#6e6e73'
              }
            },
            y: {
              title: {
                display: true,
                text: 'NH₃ Concentration (ppm)',
                font: {
                  family: "'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                  size: 11,
                  weight: '600'
                },
                color: '#1d1d1f'
              },
              min: 0,
              grid: {
                color: 'rgba(0, 0, 0, 0.06)',
                lineWidth: 1
              },
              ticks: {
                font: {
                  family: "'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                  size: 9
                },
                color: '#6e6e73'
              }
            }
          }
        }
      });
    }

    function startLeakAnimation() {
      leakIndex = 0;
      leakTimer = setInterval(() => {
        if (leakIndex < leakData.length) {
          const point = leakData[leakIndex];
          point.yValues.forEach((val, idx) => {
            leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
          });
          leakChart.options.scales.x.max = leakData[leakIndex].x + 1;
          leakChart.update();
          leakIndex++;
        } else {
          clearInterval(leakTimer);
        }
      }, 1000 / CHART_SPEED_FACTOR);
    }

    function showChartPopup() {
      if (isMobileDevice()) {
        adjustPopupForMobile();
      } else {
        // Smaller popup positioned at bottom-right to not obstruct 3D view
        popup.style.width = '400px';
        popup.style.height = '300px';
        popup.style.top = 'auto';
        popup.style.left = 'auto';
        popup.style.bottom = '20px';
        popup.style.right = '20px';
        popup.style.transform = 'none';
        
        // Add semi-transparent background for better visibility of 3D scene behind
        popup.style.background = 'rgba(248, 249, 250, 0.92)';
      }
      
      // Show popup with animation
      popup.classList.add('show');
    }

    // AI-based leak detection (using scenario 7 data)
    async function LeakDetection() {
      // Check if detection is already active and toggle off if needed
      if (toggleStates.detection) {
        closePopup();
        toggleStates.detection = false;
        updateButtonStates();
        return;
      }
      
      // Ensure clean state before proceeding
      await ensureCleanState();
      
      // Reset other toggles and set detection to true
      Object.keys(toggleStates).forEach(key => toggleStates[key] = false);
      toggleStates.detection = true;
      updateButtonStates();

      popupLocked = false;
      popupTitleElement.textContent = "AI 기반 누출 추정 - Leak #7";

      // Create status cubes with wireframe
      const geometry = new THREE.BoxGeometry(2, 10, 3);
      
      const statusCube1 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 }));
      const statusCube2 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 }));
      const statusCube3 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 }));

      // Add wireframes with explicit red color initialization
      const edges1 = new THREE.EdgesGeometry(geometry);
      const edges2 = new THREE.EdgesGeometry(geometry);
      const edges3 = new THREE.EdgesGeometry(geometry);
      
      const wireframe1 = new THREE.LineSegments(edges1, new THREE.LineBasicMaterial({ color: 0xff0000 })); // Red wireframe
      const wireframe2 = new THREE.LineSegments(edges2, new THREE.LineBasicMaterial({ color: 0xff0000 })); // Red wireframe
      const wireframe3 = new THREE.LineSegments(edges3, new THREE.LineBasicMaterial({ color: 0xff0000 })); // Red wireframe

      statusCube1.position.set(3.5, -1, 2);
      statusCube2.position.set(-0.4, -1, 2);
      statusCube3.position.set(-4.3, -1, 2);

      wireframe1.position.set(3.5, -1, 2);
      wireframe2.position.set(-0.4, -1, 2);
      wireframe3.position.set(-4.3, -1, 2);

      statusCube1.name = 'GE#1';
      statusCube2.name = 'GE#2';
      statusCube3.name = 'GE#3';
      
      wireframe1.name = 'GE#1_wire';
      wireframe2.name = 'GE#2_wire';
      wireframe3.name = 'GE#3_wire';

      scene.add(statusCube1);
      scene.add(statusCube2);
      scene.add(statusCube3);
      scene.add(wireframe1);
      scene.add(wireframe2);
      scene.add(wireframe3);

      // Force initial color state to red for all cubes and wireframes
      setTimeout(() => {
        [statusCube1, statusCube2, statusCube3].forEach((cube, idx) => {
          if (cube && cube.material) {
            cube.material.color.setRGB(1, 0, 0); // Red cubes initially
          }
          const wire = scene.getObjectByName(`GE#${idx + 1}_wire`);
          if (wire && wire.material) {
            wire.material.color.setRGB(1, 0, 0); // Red wireframes initially
          }
        });
      }, 50); // Small delay to ensure objects are properly added to scene

      const csvPath = './sensor_data/scenario_7-1.csv';
      const backupPath = 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/sensor_data/scenario_7-1.csv';

      fetch(csvPath)
        .then(response => {
          if (!response.ok) {
            return fetch(backupPath);
          }
          return response;
        })
        .catch(() => fetch(backupPath))
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          return response.text();
        })
        .then(csvText => {
          const lines = csvText.trim().split('\n').filter(line => line.trim() !== '');
          const headers = lines[0].split(',').map(h => h.trim());
          const timeIdx = headers.findIndex(h => h.toLowerCase().includes('time'));

          if (timeIdx === -1) {
            throw new Error("시간 컬럼을 찾을 수 없습니다.");
          }

          const valueIndices = headers
            .map((h, i) => ({ name: h.trim(), idx: i }))
            .filter(obj => !obj.name.toLowerCase().includes('time') && obj.name !== '');

          if (valueIndices.length === 0) {
            throw new Error("센서 데이터 컬럼을 찾을 수 없습니다.");
          }

          leakData = [];
          for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',').map(p => p.trim());
            if (parts.length !== headers.length) continue; // Skip malformed rows
            
            const time = parseFloat(parts[timeIdx]);
            if (isNaN(time)) continue; // Skip invalid time values
            
            const values = valueIndices.map(obj => {
              const val = parseFloat(parts[obj.idx]);
              return isNaN(val) ? 0 : val; // Default to 0 for invalid values
            });
            
            leakData.push({ x: time, yValues: values });
          }

          if (leakData.length === 0) {
            throw new Error("유효한 데이터가 없습니다.");
          }

          console.log(`LeakDetection: 로드된 데이터 포인트 수: ${leakData.length}, 최대 시간: ${leakData[leakData.length - 1].x}초`);
          
          createLeakChart(valueIndices, 7);
          showChartPopup();

          leakIndex = 0;
          leakTimer = setInterval(() => {
            if (leakIndex < leakData.length) {
              const point = leakData[leakIndex];
              point.yValues.forEach((val, idx) => {
                if (idx < leakChart.data.datasets.length) {
                  leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
                }
              });
              leakChart.options.scales.x.max = leakData[leakIndex].x + 1;

              // Find the highest sensor value and corresponding cube
              if (point.yValues.length >= 3) {
                const maxValue = Math.max(...point.yValues);
                const maxIndex = point.yValues.indexOf(maxValue);
                
                // Reset all cubes to green first (during animation)
                [statusCube1, statusCube2, statusCube3].forEach((cube, idx) => {
                  if (cube && cube.material) {
                    cube.material.color.setRGB(0, 1, 0);
                  }
                  const wire = scene.getObjectByName(`GE#${idx + 1}_wire`);
                  if (wire && wire.material) wire.material.color.setRGB(0, 1, 0);
                });
                
                // Only highlight the cube with highest sensor reading
                const cubes = [statusCube1, statusCube2, statusCube3];
                const redIntensity = Math.min(1, maxValue * 2); // Scale the red intensity
                const greenIntensity = Math.max(0, 1 - redIntensity);
                
                if (cubes[maxIndex] && cubes[maxIndex].material) {
                  cubes[maxIndex].material.color.setRGB(redIntensity, greenIntensity, 0);
                }
                const wire = scene.getObjectByName(`GE#${maxIndex + 1}_wire`);
                if (wire && wire.material) wire.material.color.setRGB(redIntensity, greenIntensity, 0);
              }

              leakChart.update();
              leakIndex++;
            } else {
              console.log("LeakDetection: 모든 데이터 처리 완료");
              clearInterval(leakTimer);
            }
          }, 1000 / CHART_SPEED_FACTOR);
        })
        .catch(error => {
          console.error('LeakDetection CSV 로드 실패:', error);
          document.getElementById('popup-content').innerHTML = `
            <div style="padding: 20px; text-align: center;">
              <p style="color:red; font-weight: bold;">CSV 로드 실패</p>
              <p style="color:#666; font-size: 0.9em;">${error.message}</p>
              <p style="color:#666; font-size: 0.8em;">경로: ${csvPath}</p>
              <p style="color:#666; font-size: 0.8em;">백업: ${backupPath}</p>
            </div>
          `;
          showChartPopup();
        });
    }

    // Ammonia dispersion simulation with enhanced physics
    async function Dispersion() {
      if (toggleStates.dispersion) {
        closePopup();
        toggleStates.dispersion = false;
        updateButtonStates();
        return;
      }
      
      // Ensure clean state before proceeding
      await ensureCleanState();
      
      // Close any existing popup first
      if (popup.classList.contains('show')) {
        closePopup();
      }
      
      // Reset other toggles
      Object.keys(toggleStates).forEach(key => toggleStates[key] = false);
      toggleStates.dispersion = true;
      updateButtonStates();
      
      // External box dimensions
      const boxWidth = 13.8;
      const boxHeight = 21.5;
      const boxDepth = 7.5;
      const halfW = boxWidth / 2;
      const halfH = boxHeight / 2;
      const halfD = boxDepth / 2;

      // Draw external box
      const outerBox = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      const outerEdges = new THREE.EdgesGeometry(outerBox);
      const outerMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
      const outerWireframe = new THREE.LineSegments(outerEdges, outerMaterial);
      dispersionGroup.add(outerWireframe);

      // Internal obstacles with enhanced physics properties
      const obstacles = [
        { center: new THREE.Vector3(3.5, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-0.4, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-4.3, -1, 2), size: new THREE.Vector3(2, 10, 3) }
      ];

      obstacles.forEach(obs => {
        const halfSize = obs.size.clone().multiplyScalar(0.5);
        obs.min = obs.center.clone().sub(halfSize);
        obs.max = obs.center.clone().add(halfSize);

        const geom = new THREE.BoxGeometry(obs.size.x, obs.size.y, obs.size.z);
        const edges = new THREE.EdgesGeometry(geom);
        const mat = new THREE.LineBasicMaterial({ color: 0x666666 });
        const wire = new THREE.LineSegments(edges, mat);
        wire.position.copy(obs.center);
        dispersionGroup.add(wire);
      });

      // Create 3D volume visualization (4×4 grid with full Z-axis height per section)
      const gridCountX = 4;
      const gridCountY = 4;
      const gridWidth = boxWidth / gridCountX;
      const gridHeight = boxHeight / gridCountY;

      const gridPlanes = [];
      for (let i = 0; i < gridCountX; i++) {
        for (let j = 0; j < gridCountY; j++) {
          // Use BoxGeometry for proper 3D volume representation
          const geometry = new THREE.BoxGeometry(
            gridWidth * 0.95, 
            gridHeight * 0.95, 
            boxDepth * 0.95
          );
          const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.0,
            side: THREE.DoubleSide
          });
          const volumeBox = new THREE.Mesh(geometry, material);
          
          // Position volume box at the center of the grid cell
          volumeBox.position.set(
            -halfW + gridWidth * (i + 0.5),
            -halfH + gridHeight * (j + 0.5),
            0 // Centered in Z-axis
          );
          
          dispersionGroup.add(volumeBox);
          gridPlanes.push({ 
            mesh: volumeBox, 
            count: 0, 
            maxCount: 0,
            gridX: i, 
            gridY: j
          });
        }
      }

      // Enhanced leak source with turbulence
      const leakSource = new THREE.Vector3(4.5, 0.0, 2.0);

      // Enhanced particle system with Navier-Stokes inspired physics
      const particles = [];
      const maxParticles = 1500;
      const emissionRate = 50; // particles per second
      const timeStep = 0.016; // ~60fps
      const baseSpeed = 0.08;
      const turbulenceStrength = 0.02;
      const viscosity = 0.98;
      const maxAge = 150.0;
      
      // Wind field for realistic flow
      const windField = {
        x: 0.01,
        y: -0.01, // slight downward draft
        z: 0.03
      };

      let lastEmissionTime = 0;

      function createParticle() {
        // Enhanced initial velocity with turbulence
        const baseDirection = new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 1.5 - 0.5, // bias upward initially
          Math.random() * 2 - 1
        ).normalize();
        
        // Add turbulence
        const turbulence = new THREE.Vector3(
          (Math.random() - 0.5) * turbulenceStrength,
          (Math.random() - 0.5) * turbulenceStrength,
          (Math.random() - 0.5) * turbulenceStrength
        );
        
        const velocity = baseDirection.multiplyScalar(baseSpeed).add(turbulence);

        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(0.05, 0.8, 0.6), // Orange-red
          transparent: true,
          opacity: 0.7
        });

        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.08, 8, 8),
          material
        );
        
        // Add slight random offset to emission point
        const offset = new THREE.Vector3(
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2
        );
        
        particle.position.copy(leakSource).add(offset);
        particle.userData = {
          velocity: velocity,
          age: 0,
          mass: 0.8 + Math.random() * 0.4, // particle mass affects movement
          density: 1.0
        };
        
        dispersionGroup.add(particle);
        particles.push(particle);
      }

      function updateParticles() {
        const currentTime = Date.now() * 0.001;
        
        // Emit particles based on rate
        if (currentTime - lastEmissionTime > 1.0 / emissionRate) {
          if (particles.length < maxParticles) {
            createParticle();
            lastEmissionTime = currentTime;
          }
        }

        // Reset grid counts
        gridPlanes.forEach(g => g.count = 0);

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          const vel = p.userData.velocity;
          const mass = p.userData.mass;
          
          // Apply wind field (external forces)
          vel.x += windField.x * timeStep;
          vel.y += windField.y * timeStep;
          vel.z += windField.z * timeStep;
          
          // Add turbulence based on age (more turbulent as it disperses)
          const turbulenceFactor = Math.min(p.userData.age / 50.0, 1.0);
          vel.x += (Math.random() - 0.5) * turbulenceStrength * turbulenceFactor * timeStep;
          vel.y += (Math.random() - 0.5) * turbulenceStrength * turbulenceFactor * timeStep;
          vel.z += (Math.random() - 0.5) * turbulenceStrength * turbulenceFactor * timeStep;
          
          // Apply viscosity (damping)
          vel.multiplyScalar(viscosity);
          
          // Calculate next position
          const nextPos = p.position.clone().add(vel.clone().multiplyScalar(timeStep * 60));

          // Enhanced boundary collision detection
          let collided = false;
          
          // External box boundaries with momentum transfer
          if (Math.abs(nextPos.x) > halfW) {
            vel.x *= -0.7; // energy loss on collision
            vel.y *= 0.9;
            vel.z *= 0.9;
            p.position.x = Math.sign(p.position.x) * (halfW - 0.1);
            collided = true;
          }
          if (Math.abs(nextPos.y) > halfH) {
            vel.y *= -0.7;
            vel.x *= 0.9;
            vel.z *= 0.9;
            p.position.y = Math.sign(p.position.y) * (halfH - 0.1);
            collided = true;
          }
          if (Math.abs(nextPos.z) > halfD) {
            vel.z *= -0.7;
            vel.x *= 0.9;
            vel.y *= 0.9;
            p.position.z = Math.sign(p.position.z) * (halfD - 0.1);
            collided = true;
            }

          // Internal obstacle collision with improved physics
          for (const obs of obstacles) {
            if (
              nextPos.x > obs.min.x && nextPos.x < obs.max.x &&
              nextPos.y > obs.min.y && nextPos.y < obs.max.y &&
              nextPos.z > obs.min.z && nextPos.z < obs.max.z
            ) {
              const center = obs.center;
              const toParticle = p.position.clone().sub(center);
              toParticle.normalize();
              
              // Reflect velocity with energy loss
              vel.reflect(toParticle).multiplyScalar(0.6);
              
              // Add some random deflection
              vel.add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02
              ));
              
              collided = true;
              break;
            }
          }

          // Update position if no collision
          if (!collided) {
            p.position.copy(nextPos);
          }

          // Age and appearance updates
          p.userData.age += timeStep * 30;
          const ageRatio = Math.min(p.userData.age / maxAge, 1);
          
          // Enhanced color transition for better visibility
          const hue = 0.05 + ageRatio * 0.15; // red to yellow
          const saturation = Math.max(0.3, 0.8 - ageRatio * 0.5);
          const lightness = Math.max(0.3, 0.6 - ageRatio * 0.3);
          const alpha = Math.max(0, 0.7 - ageRatio * 0.7);

          p.material.color.setHSL(hue, saturation, lightness);
          p.material.opacity = alpha;
          
          // Scale changes
          const scale = 1 + ageRatio * 0.5;
          p.scale.setScalar(scale);

          // Count particles in 2D grid cells (X-Y plane only, ignore Z position)
          const px = p.position.x + halfW;
          const py = p.position.y + halfH;

          const gridI = Math.floor(px / gridWidth);
          const gridJ = Math.floor(py / gridHeight);

          if (gridI >= 0 && gridI < gridCountX && 
              gridJ >= 0 && gridJ < gridCountY) {
            const index = gridI * gridCountY + gridJ;
            if (gridPlanes[index]) {
              gridPlanes[index].count++;
            }
          }

          // Remove aged particles
          if (p.userData.age > maxAge) {
            dispersionGroup.remove(p);
            if (p.geometry) p.geometry.dispose();
            if (p.material) p.material.dispose();
            particles.splice(i, 1);
          }
        }

        // Update 2D grid colors with enhanced heatmap visualization
        const counts = gridPlanes.map(g => g.count);
        const maxCount = Math.max(1, ...counts);
        const globalMaxCount = Math.max(maxCount, ...gridPlanes.map(g => g.maxCount));

        gridPlanes.forEach(g => {
          // Track maximum count for better normalization
          g.maxCount = Math.max(g.maxCount * 0.95, g.count); // slight decay
          
          const density = g.count / Math.max(1, globalMaxCount);
          const normalizedDensity = Math.min(1, density * 2); // enhance visibility
          
          // Always show grid sections - safe areas in light green, dangerous areas in red spectrum
          let r, green, b, opacity;
          
          if (normalizedDensity > 0.05) {
            // Dangerous areas: Enhanced color mapping green -> yellow -> orange -> red
            if (normalizedDensity < 0.3) {
              // Green to yellow transition (low concentration)
              const t = normalizedDensity / 0.3;
              r = t;
              green = 1;
              b = 0;
            } else if (normalizedDensity < 0.7) {
              // Yellow to orange transition (warning zone)
              const t = (normalizedDensity - 0.3) / 0.4;
              r = 1;
              green = 1 - t * 0.5;
              b = 0;
            } else {
              // Orange to red transition (danger zone)
              const t = (normalizedDensity - 0.7) / 0.3;
              r = 1;
              green = 0.5 - t * 0.5;
              b = 0;
            }
            
            opacity = Math.min(0.4, 0.08 + normalizedDensity * 0.3);
          } else {
            // Safe areas: Light green to indicate safety
            r = 0.5;      // Light green
            green = 1.0;  // Full green
            b = 0.5;      // Light green
            opacity = 0.2; // Semi-transparent to show it's safe but still visible
          }
          
          g.mesh.material.color.setRGB(r, green, b);
          g.mesh.material.opacity = opacity;
          g.mesh.visible = true; // Always show all grid sections
        });
      }

      function animateDispersion() {
        updateParticles();
        window.dispersionAnimationId = requestAnimationFrame(animateDispersion);
      }

      isDispersionActive = true;
      animateDispersion();
    }

    function showSensorInfo(sensorObj) {
      popupLocked = false;
      popupTitleElement.textContent = sensorObj.userData.name + " - 센서 정보";
      
      const pos = sensorObj.userData.position;
      const specs = sensorObj.userData.specifications;
      
      const html = `
        <div style="font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif; line-height: 1.4; padding: 10px; box-sizing: border-box;">
          <div style="background: linear-gradient(135deg, #007AFF 0%, #0056b3 100%); color: white; padding: 12px; border-radius: 8px; margin-bottom: 12px;">
            <h3 style="margin: 0 0 6px 0; font-size: 1.1em; font-weight: 600;">${sensorObj.userData.name}</h3>
            <p style="margin: 0; opacity: 0.9; font-size: 0.85em;">NH₃ 가스 센서</p>
          </div>
          
          <div style="display: grid; gap: 10px;">
            <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; border-left: 4px solid #007AFF;">
              <h4 style="margin: 0 0 6px 0; color: #1d1d1f; font-size: 0.9em; font-weight: 600;">위치 좌표</h4>
              <p style="margin: 0; font-family: 'SF Mono', monospace; font-size: 0.8em; color: #666;">
                X: ${pos.x.toFixed(3)} m, Y: ${pos.y.toFixed(3)} m, Z: ${pos.z.toFixed(3)} m
              </p>
            </div>
            
            <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; border-left: 4px solid #34C759;">
              <h4 style="margin: 0 0 6px 0; color: #1d1d1f; font-size: 0.9em; font-weight: 600;">센서 사양</h4>
              <div style="font-size: 0.8em; color: #666; line-height: 1.3;">
                <p style="margin: 0 0 3px 0;"><strong>센서 타입:</strong> EC</p>
                <p style="margin: 0 0 3px 0;"><strong>측정 범위:</strong> 0 ~ 100 ppm</p>
                <p style="margin: 0;"><strong>정확도:</strong> ±2 %</p>
              </div>
            </div>
            
            <div style="background: #fff3cd; padding: 10px; border-radius: 6px; border-left: 4px solid #FF9500;">
              <h4 style="margin: 0 0 6px 0; color: #1d1d1f; font-size: 0.9em; font-weight: 600;">상태</h4>
              <p style="margin: 0; font-size: 0.8em; color: #666;">
                <span class="sensor-status-indicator" style="display: inline-block; width: 8px; height: 8px; background: #34C759; border-radius: 50%; margin-right: 6px;"></span>
                정상 작동 중
              </p>
            </div>
          </div>
        </div>
      `;

      document.getElementById('popup-content').innerHTML = html;
      
      if (isMobileDevice()) {
        adjustPopupForMobile('sensor');
      } else {
        // Position sensor info popup at bottom-right like chart popups
        popup.style.width = '380px';
        popup.style.height = '320px';
        popup.style.top = 'auto';
        popup.style.left = 'auto';
        popup.style.bottom = '20px';
        popup.style.right = '20px';
        popup.style.transform = 'none';
        popup.style.background = 'rgba(248, 249, 250, 0.92)';
      }
      
      // Show popup with animation
      popup.classList.add('show');
    }

    // Enhanced cleanup function with immediate cache clearing
    function clearAllCache() {
      // Stop neural network animation immediately
      if (window.neuralNetAnimationId) {
        cancelAnimationFrame(window.neuralNetAnimationId);
        window.neuralNetAnimationId = null;
      }

      // Stop chart animation immediately
      if (leakTimer) {
        clearInterval(leakTimer);
        leakTimer = null;
      }
      if (leakChart) {
        leakChart.destroy();
        leakChart = null;
      }

      // Stop dispersion animation immediately
      if (window.dispersionInterval) {
        clearInterval(window.dispersionInterval);
        window.dispersionInterval = null;
      }
      if (window.dispersionAnimationId) {
        cancelAnimationFrame(window.dispersionAnimationId);
        window.dispersionAnimationId = null;
      }

      // Clear dispersion objects immediately
      if (dispersionGroup) {
        dispersionGroup.clear();
      }
      isDispersionActive = false;

      // Remove status cubes and wireframes immediately
      ['GE#1', 'GE#2', 'GE#3', 'GE#1_wire', 'GE#2_wire', 'GE#3_wire'].forEach(objName => {
        const existingObj = scene.getObjectByName(objName);
        if (existingObj) {
          scene.remove(existingObj);
          if (existingObj.geometry) existingObj.geometry.dispose();
          if (existingObj.material) {
            if (Array.isArray(existingObj.material)) {
              existingObj.material.forEach(mat => mat.dispose());
            } else {
              existingObj.material.dispose();
            }
          }
        }
      });

      // Clear stored chart data to prevent cache issues
      Object.keys(storedChartData).forEach(key => {
        delete storedChartData[key];
      });

      // Reset data arrays
      leakData = [];
      leakIndex = 0;

      // Clear any cached network data
      if (window.networkCtx) {
        window.networkCtx.clearRect(0, 0, window.networkCanvas.width, window.networkCanvas.height);
      }
      
      // Force garbage collection by nullifying references
      if (window.networkCanvas) {
        window.networkCanvas = null;
        window.networkCtx = null;
      }
    }

    // Enhanced function to ensure clean state before starting new features
    function ensureCleanState() {
      return new Promise((resolve) => {
        clearAllCache();
        // Small delay to ensure all cleanup is complete
        setTimeout(resolve, 10);
      });
    }

    function closePopup() {
      // Immediately clear all cache and stop animations to prevent interference
      clearAllCache();
      
      // Reset all toggle states
      Object.keys(toggleStates).forEach(key => toggleStates[key] = false);
      updateButtonStates();
      
      // Hide popup with animation
      popup.classList.remove('show');

      popupLocked = false;
    }

    // Global helper function to get current translate values
    function getCurrentTranslate() {
      const transform = popup.style.transform;
      if (!transform || transform === 'none') return { x: 0, y: 0 };
      
      // Try to match translate3d first, then translate with calc
      let match = transform.match(/translate3d\(calc\(-50% \+ (-?\d+(?:\.\d+)?)px\), calc\(-50% \+ (-?\d+(?:\.\d+)?)px\), 0\)/);
      if (match) {
        return { x: parseFloat(match[1]), y: parseFloat(match[2]) };
      }
      
      // Fallback to regular translate with calc
      match = transform.match(/translate\(calc\(-50% \+ (-?\d+(?:\.\d+)?)px\), calc\(-50% \+ (-?\d+(?:\.\d+)?)px\)\)/);
      if (match) {
        return { x: parseFloat(match[1]), y: parseFloat(match[2]) };
      }
      
      // Fallback to simple translate
      match = transform.match(/translate\((-?\d+(?:\.\d+)?)px,\s*(-?\d+(?:\.\d+)?)px\)/);
      if (match) {
        return { x: parseFloat(match[1]), y: parseFloat(match[2]) };
      }
      
      // Check for basic translate(-50%, -50%) - this means no drag offset
      if (transform.includes('translate(-50%, -50%)')) {
        return { x: 0, y: 0 };
      }
      
      return { x: 0, y: 0 };
    }

    // Enhanced function to get actual popup position including computed styles
    function getActualPopupPosition() {
      const rect = popup.getBoundingClientRect();
      const viewportCenterX = window.innerWidth / 2;
      const viewportCenterY = window.innerHeight / 2;
      
      // Calculate the offset from center
      const popupCenterX = rect.left + rect.width / 2;
      const popupCenterY = rect.top + rect.height / 2;
      
      const offsetX = popupCenterX - viewportCenterX;
      const offsetY = popupCenterY - viewportCenterY;
      
      return { x: offsetX, y: offsetY };
    }

    // Global function to preserve drag position when popup is reopened
    function preservePopupPosition() {
      if (!isMobileDevice()) {
        // Check if popup is already visible and has been moved from center
        if (popup.classList.contains('show')) {
          const actualPosition = getActualPopupPosition();
          if (Math.abs(actualPosition.x) > 5 || Math.abs(actualPosition.y) > 5) {
            // If popup was previously dragged (more than 5px from center), maintain that position
            popup.style.left = '50%';
            popup.style.top = '50%';
            popup.style.transform = `translate3d(calc(-50% + ${actualPosition.x}px), calc(-50% + ${actualPosition.y}px), 0)`;
            return;
          }
        }
        
        // Fallback to parsed transform for initial positioning
        const currentTranslate = getCurrentTranslate();
        if (currentTranslate.x !== 0 || currentTranslate.y !== 0) {
          // If popup was previously dragged, maintain that position
          popup.style.left = '50%';
          popup.style.top = '50%';
          popup.style.transform = `translate3d(calc(-50% + ${currentTranslate.x}px), calc(-50% + ${currentTranslate.y}px), 0)`;
        } else {
          // Reset to center if no previous drag
          popup.style.left = '50%';
          popup.style.top = '50%';
          popup.style.transform = 'translate(-50%, -50%)';
        }
      }
    }

    function setupEventListeners() {
      // Draggable popup - Desktop only (Mobile uses fixed positioning)
      let isDragging = false;
      let startX = 0, startY = 0;
      let initialTranslateX = 0, initialTranslateY = 0;
      let dragAnimationId = null;

      // Desktop-only dragging functionality
      if (!isMobileDevice()) {
        // Desktop mouse events for dragging
        popupHeader.addEventListener('mousedown', (e) => {
          // Skip if clicking on close button
          if (e.target.closest('#closeButton')) return;
          
          e.preventDefault();
          isDragging = true;
          
          // Disable transitions during dragging for immediate response
          popup.classList.add('dragging');
          
          // Get starting mouse position
          startX = e.clientX;
          startY = e.clientY;
          
          // Use actual popup position instead of parsed transform to fix origin issue
          const actualPosition = getActualPopupPosition();
          initialTranslateX = actualPosition.x;
          initialTranslateY = actualPosition.y;
          
          // Debug: Log current state with both methods
          const parsedTranslate = getCurrentTranslate();
          console.log('Drag start:', {
            mouseX: startX,
            mouseY: startY,
            currentTransform: popup.style.transform,
            parsedTranslateX: parsedTranslate.x,
            parsedTranslateY: parsedTranslate.y,
            actualTranslateX: initialTranslateX,
            actualTranslateY: initialTranslateY
          });
          
          document.body.style.userSelect = 'none';
          popupHeader.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
          if (isDragging) {
            e.preventDefault();
            
            // Use requestAnimationFrame for smoother movement
            if (dragAnimationId) {
              cancelAnimationFrame(dragAnimationId);
            }
            
            dragAnimationId = requestAnimationFrame(() => {
              // Calculate the movement delta
              const deltaX = e.clientX - startX;
              const deltaY = e.clientY - startY;
              
              // Apply the movement to the initial position
              const newX = initialTranslateX + deltaX;
              const newY = initialTranslateY + deltaY;
              
              // Update popup position with hardware acceleration
              popup.style.left = '50%';
              popup.style.top = '50%';
              popup.style.transform = `translate3d(calc(-50% + ${newX}px), calc(-50% + ${newY}px), 0)`;
            });
          }
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            
            // Cancel any pending animation frame
            if (dragAnimationId) {
              cancelAnimationFrame(dragAnimationId);
              dragAnimationId = null;
            }
            
            // Re-enable transitions after dragging ends
            popup.classList.remove('dragging');
            
            document.body.style.userSelect = '';
            popupHeader.style.cursor = 'grab';
          }
        });

        // Desktop zoom functionality for popup content
        popup.addEventListener('wheel', (e) => {
          // Only allow zooming on charts and network visualizations
          if (e.target.closest('#leakChart') || e.target.closest('#networkCanvas')) {
            e.preventDefault();
            const element = e.target.closest('canvas');
            if (element) {
              const rect = element.getBoundingClientRect();
              const scaleX = (e.clientX - rect.left) / rect.width;
              const scaleY = (e.clientY - rect.top) / rect.height;
              
              const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
              const currentScale = element.style.transform?.match(/scale\(([^)]+)\)/)?.[1] || 1;
              const newScale = Math.max(0.5, Math.min(3, currentScale * scaleFactor));
              
              element.style.transformOrigin = `${scaleX * 100}% ${scaleY * 100}%`;
              element.style.transform = `scale(${newScale})`;
            }
          }
        });
      } else {
        // Mobile-specific touch handling for popup content (zoom/pan for charts)
        let isPinching = false;
        let initialDistance = 0;
        let initialScale = 1;
        let isDraggingPopup = false;
        let startX = 0, startY = 0;
        let initialTranslateX = 0, initialTranslateY = 0;
        let touchDragAnimationId = null;
        
        // Enhanced close button for mobile
        const closeButton = document.getElementById('closeButton');
        if (closeButton) {
          closeButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closePopup();
          }, { passive: false });
          
          closeButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closePopup();
          });
        }

        // Popup dragging for mobile
        popupHeader.addEventListener('touchstart', (e) => {
          if (e.target.closest('#closeButton')) return;
          
          e.preventDefault();
          isDraggingPopup = true;
          
          // Disable transitions during dragging for immediate response
          popup.classList.add('dragging');
          
          const touch = e.touches[0];
          startX = touch.clientX;
          startY = touch.clientY;
          
          // Use actual popup position for mobile touch too
          const actualPosition = getActualPopupPosition();
          initialTranslateX = actualPosition.x;
          initialTranslateY = actualPosition.y;
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
          if (isDraggingPopup) {
            e.preventDefault();
            
            // Use requestAnimationFrame for smoother movement
            if (touchDragAnimationId) {
              cancelAnimationFrame(touchDragAnimationId);
            }
            
            touchDragAnimationId = requestAnimationFrame(() => {
              const touch = e.touches[0];
              const deltaX = touch.clientX - startX;
              const deltaY = touch.clientY - startY;
              
              const newX = initialTranslateX + deltaX;
              const newY = initialTranslateY + deltaY;
              
              // Update popup position with hardware acceleration
              popup.style.left = '50%';
              popup.style.top = '50%';
              popup.style.transform = `translate3d(calc(-50% + ${newX}px), calc(-50% + ${newY}px), 0)`;
            });
          }
        }, { passive: false });

        document.addEventListener('touchend', () => {
          if (isDraggingPopup) {
            // Cancel any pending animation frame
            if (touchDragAnimationId) {
              cancelAnimationFrame(touchDragAnimationId);
              touchDragAnimationId = null;
            }
            
            // Re-enable transitions after dragging ends
            popup.classList.remove('dragging');
          }
          isDraggingPopup = false;
        });
        
        popup.addEventListener('touchstart', (e) => {
          if (e.touches.length === 2 && (e.target.closest('#leakChart') || e.target.closest('#networkCanvas'))) {
            e.preventDefault();
            isPinching = true;
            
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );
            
            const element = e.target.closest('canvas');
            if (element) {
              const currentScale = element.style.transform?.match(/scale\(([^)]+)\)/)?.[1] || 1;
              initialScale = parseFloat(currentScale);
            }
          }
        }, { passive: false });
        
        popup.addEventListener('touchmove', (e) => {
          if (isPinching && e.touches.length === 2) {
            e.preventDefault();
            
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );
            
            const scale = (currentDistance / initialDistance) * initialScale;
            const clampedScale = Math.max(0.5, Math.min(3, scale));
            
            const element = e.target.closest('canvas');
            if (element) {
              element.style.transform = `scale(${clampedScale})`;
            }
          }
        }, { passive: false });
        
        popup.addEventListener('touchend', () => {
          isPinching = false;
        });
      }

      // ESC key support for closing popups and sidebar
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (sidebarOpen) {
            closeMobileSidebar();
          } else if (popup.classList.contains('show')) {
            closePopup();
          }
        }
      });

      // Responsive resize
      window.addEventListener('resize', () => {
        const container = document.getElementById('viewer');
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      // Click handling for 3D objects
      window.addEventListener('click', (event) => {
        if (
          event.target.closest('#popup') ||
          event.target.closest('#overlay-buttons') ||
          event.target.closest('#leak-buttons') ||
          event.target.closest('#guide-button') ||
          event.target.closest('#toggle-labels-btn')
        ) return;

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(window.clickableCubes);

        if (intersects.length > 0) {
          const obj = intersects[0].object;

          // Handle sensor clicks
          if (obj.userData.type === 'sensor') {
            showSensorInfo(obj);
          }
          // Handle leak point clicks
          else if (obj.userData.name?.startsWith('Leak')) {
            const leakNumber = obj.userData.leakNumber;
            if (leakNumber && leakNumber <= 6) {
              showLeakData(leakNumber);
            } else if (leakNumber === 7) {
              // Ensure detection toggle state is properly set before calling LeakDetection
              toggleStates.detection = false; // Reset first to ensure proper toggle
              updateButtonStates(); // Update UI to reflect the state
              LeakDetection(); // This will now properly set detection to true
            }
          }
        }
      });

      // Mouse hover effects
      window.addEventListener('mousemove', (event) => {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(window.clickableCubes);

        if (intersects.length > 0) {
          if (INTERSECTED !== intersects[0].object) {
            if (INTERSECTED) {
              const originalColor = INTERSECTED.userData.originalColor || 0xff0000;
              INTERSECTED.material.color.set(originalColor);
            }

            INTERSECTED = intersects[0].object;
            INTERSECTED.material.color.set(0xffff00);
          }
        } else {
          if (INTERSECTED) {
            const originalColor = INTERSECTED.userData.originalColor || 0xff0000;
            INTERSECTED.material.color.set(originalColor);
            INTERSECTED = null;
          }
        }
      });
    }

    // Toggle guide system
    async function toggleGuide() {
      if (toggleStates.guide) {
        closePopup();
        toggleStates.guide = false;
        updateButtonStates();
        return;
      }
      
      // Ensure clean state before proceeding
      await ensureCleanState();
      
      // Reset other toggles
      Object.keys(toggleStates).forEach(key => toggleStates[key] = false);
      toggleStates.guide = true;
      updateButtonStates();
      
      showGuide();
    }

    // 훈련 데이터셋 기능 토글
    function toggleTrainingDataset() {
      const button = document.getElementById('training-dataset-button');
      const container = document.getElementById('training-leak-buttons');
      const arrow = button.querySelector('.expand-arrow');
      
      if (container.classList.contains('hidden')) {
        // 훈련 누출 버튼들 표시
        container.classList.remove('hidden');
        button.classList.add('expanded');
        arrow.textContent = '▲'; // ▲ for expanded state
      } else {
        // 훈련 누출 버튼들 숨기기
        container.classList.add('hidden');
        button.classList.remove('expanded');
        arrow.textContent = '▼'; // ▼ for collapsed state
      }
    }

    // Mobile sidebar functions
    function toggleMobileSidebar() {
      if (sidebarOpen) {
        closeMobileSidebar();
      } else {
        openMobileSidebar();
      }
    }

    function openMobileSidebar() {
      const sidebar = document.getElementById('mobile-sidebar');
      const overlay = document.getElementById('mobile-sidebar-overlay');
      const toggle = document.getElementById('mobile-menu-toggle');
      
      sidebar.classList.add('open');
      overlay.classList.add('active');
      toggle.classList.add('active');
      sidebarOpen = true;
      
      // Prevent body scrolling when sidebar is open
      document.body.style.overflow = 'hidden';
    }

    function closeMobileSidebar() {
      const sidebar = document.getElementById('mobile-sidebar');
      const overlay = document.getElementById('mobile-sidebar-overlay');
      const toggle = document.getElementById('mobile-menu-toggle');
      
      sidebar.classList.remove('open');
      overlay.classList.remove('active');
      toggle.classList.remove('active');
      sidebarOpen = false;
      
      // Restore body scrolling
      document.body.style.overflow = '';
    }

    // Enhanced popup positioning for mobile
    function adjustPopupForMobile(popupType = 'default') {
      if (!isMobileDevice()) return;
      
      const popup = document.getElementById('popup');
      
      // Clear any dragging transforms that might interfere with mobile positioning
      popup.style.transform = '';
      
      // Enhanced acrylic transparency for mobile to show background
      popup.style.background = 'rgba(248, 249, 250, 0.85)';
      
      // Remove any existing popup type classes
      popup.classList.remove('guide-popup', 'sensor-popup', 'learning-popup');
      
      // Apply different styles based on popup type
      if (popupType === 'guide') {
        // Add guide-popup class for CSS styling
        popup.classList.add('guide-popup');
        
        // These styles will be applied by CSS, but keeping for fallback
        popup.style.width = '90vw';
        popup.style.maxWidth = '90vw';
        popup.style.height = '67vh'; // 2/3 of screen height
        popup.style.maxHeight = '67vh';
        popup.style.top = '50%';
        popup.style.left = '50%';
        popup.style.transform = 'translate(-50%, -50%)';
        popup.style.bottom = 'auto';
        popup.style.right = 'auto';
        
        // For very small screens
        if (window.innerWidth <= 480) {
          popup.style.width = '95vw';
          popup.style.height = '70vh';
        }
        
      } else if (popupType === 'learning') {
        // AI Learning popup - centered with 1/2 screen height
        popup.classList.add('learning-popup');
        
        popup.style.width = '90vw';
        popup.style.maxWidth = '90vw';
        popup.style.height = '50vh'; // 1/2 of screen height as requested
        popup.style.maxHeight = '50vh';
        popup.style.top = '50%';
        popup.style.left = '50%';
        popup.style.transform = 'translate(-50%, -50%)';
        popup.style.bottom = 'auto';
        popup.style.right = 'auto';
        
        // For very small screens
        if (window.innerWidth <= 480) {
          popup.style.width = '95vw';
          popup.style.height = '45vh';
        }
        
      } else if (popupType === 'sensor') {
        // Add sensor-popup class for CSS styling
        popup.classList.add('sensor-popup');
        popup.style.width = '90vw';
        popup.style.maxWidth = '90vw';
        popup.style.height = '50vh'; // 1/2 of screen
        popup.style.maxHeight = '50vh';
        popup.style.top = 'auto';
        popup.style.left = 'auto';
        popup.style.bottom = '5vw';
        popup.style.right = '5vw';
        popup.style.transform = 'none';
        
        // For very small screens
        if (window.innerWidth <= 480) {
          popup.style.width = '95vw';
          popup.style.height = '45vh';
          popup.style.bottom = '2.5vw';
          popup.style.right = '2.5vw';
        }
        
      } else {
        // Default popup (charts) - improved aspect ratio for mobile
        popup.style.width = '90vw';
        popup.style.maxWidth = '90vw';
        popup.style.height = '40vh'; // Increased from 35vh for better chart aspect ratios
        popup.style.maxHeight = '40vh';
        popup.style.top = 'auto';
        popup.style.left = 'auto';
        popup.style.bottom = '5vw';
        popup.style.right = '5vw';
        popup.style.transform = 'none';
        
        // For very small screens (phones in portrait)
        if (window.innerWidth <= 480) {
          popup.style.width = '95vw';
          popup.style.height = '35vh'; // Increased from 30vh for better visibility
          popup.style.bottom = '2.5vw';
          popup.style.right = '2.5vw';
        }
      }
      
      // For landscape orientation on mobile
      if (window.innerWidth > window.innerHeight && window.innerWidth <= 1024) {
        if (popupType === 'guide') {
          popup.style.width = '80vw';
          popup.style.height = '75vh';
        } else if (popupType === 'sensor') {
          popup.style.width = '70vw';
          popup.style.height = '55vh';
          popup.style.bottom = '5vh';
          popup.style.right = '5vw';
        } else {
          popup.style.width = '60vw'; // Smaller width in landscape
          popup.style.height = '40vh';
          popup.style.bottom = '5vh';
          popup.style.right = '5vw';
        }
      }
    }

    // Initialize mobile-specific features
    function initializeMobileFeatures() {
      if (isMobileDevice()) {
        // Add mobile class to body for additional styling
        document.body.classList.add('mobile-device');
        
        // Improve viewport settings for mobile
        let viewport = document.querySelector('meta[name="viewport"]');
        if (viewport) {
          viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes');
        }
        
        // Close sidebar when clicking outside
        document.addEventListener('touchstart', (e) => {
          const sidebar = document.getElementById('mobile-sidebar');
          const toggle = document.getElementById('mobile-menu-toggle');
          
          if (sidebarOpen && 
              !sidebar.contains(e.target) && 
              !toggle.contains(e.target)) {
            closeMobileSidebar();
          }
        });
        
        // Enhanced touch handling for 3D interactions
        let touchStartY = 0;
        let touchStartX = 0;
        let isTouch3D = false;
        
        document.addEventListener('touchstart', (e) => {
          touchStartY = e.touches[0].clientY;
          touchStartX = e.touches[0].clientX;
          
          // Check if touch is on 3D viewer
          isTouch3D = e.target.closest('#viewer') !== null;
        });
        
        document.addEventListener('touchmove', (e) => {
          if (isTouch3D && e.touches.length <= 2) {
            const touchY = e.touches[0].clientY;
            const touchX = e.touches[0].clientX;
            const deltaY = Math.abs(touchStartY - touchY);
            const deltaX = Math.abs(touchStartX - touchX);
            
            // Prevent page scroll when interacting with 3D scene
            if (deltaY > 10 || deltaX > 10) {
              e.preventDefault();
            }
          }
        }, { passive: false });
        
        // Add haptic feedback for button interactions on mobile (if supported)
        const addHapticFeedback = (element) => {
          element.addEventListener('touchstart', () => {
            if (navigator.vibrate) {
              navigator.vibrate(10); // Short vibration
            }
          });
        };
        
        // Apply haptic feedback to all interactive elements
        document.querySelectorAll(`
          .sidebar-button, 
          .sidebar-leak-button, 
          .mobile-menu-toggle,
          #overlay-buttons button,
          #training-dataset-button,
          #training-leak-buttons button,
          #guide-button,
          .toggle-switch,
          #popup-header button,
          .network-controls button
        `).forEach(addHapticFeedback);
        
        // Also add haptic feedback to toggle switch
        const toggleSwitch = document.getElementById('toggle-switch');
        if (toggleSwitch) {
          addHapticFeedback(toggleSwitch);
        }
        
        // Optimize renderer for mobile performance
        if (renderer) {
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.antialias = window.devicePixelRatio === 1;
        }
        
        console.log('Mobile features initialized');
      } else {
        console.log('Desktop mode detected');
      }
    }

    // User-friendly guide system with comprehensive tutorial
    function showGuide() {
      popupLocked = false;
      popupTitleElement.textContent = "💡 시스템 사용법 가이드";
      
      const html = `
        <div style="font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif; line-height: 1.6; padding: 15px; box-sizing: border-box; height: 100%; overflow-y: auto;">
          
          <!-- Header Section -->
          <div style="background: linear-gradient(135deg, #007AFF 0%, #0056b3 100%); color: white; padding: 15px; border-radius: 12px; margin-bottom: 20px; text-align: center;">
            <h2 style="margin: 0 0 8px 0; font-size: 1.4em; font-weight: 700;">AI 누출원 탐지 시스템</h2>
            <p style="margin: 0; opacity: 0.9; font-size: 0.95em;">사용법 가이드</p>
          </div>

          <!-- Main Features -->
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1d1d1f; font-size: 1.1em; font-weight: 600; margin: 0 0 12px 0; border-bottom: 2px solid #007AFF; padding-bottom: 5px;">🎯 주요 기능</h3>
            
            <div style="display: grid; gap: 12px;">
              <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border-left: 4px solid #007AFF;">
                <h4 style="margin: 0 0 6px 0; color: #007AFF; font-size: 0.95em; font-weight: 600;">🤖 AI 신경망 학습</h4>
                <p style="margin: 0; font-size: 0.85em; color: #666;">딥러닝 신경망의 실시간 학습 과정을 시각화합니다. 마우스 드래그로 이동, 휠로 확대/축소 가능합니다.</p>
              </div>
              
              <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border-left: 4px solid #28a745;">
                <h4 style="margin: 0 0 6px 0; color: #28a745; font-size: 0.95em; font-weight: 600;">🔍 AI 기반 누출 탐지</h4>
                <p style="margin: 0; font-size: 0.85em; color: #666;">학습된 AI 모델로 누출원(Leak #7)을 탐지하고 분석합니다.</p>
              </div>
              
              <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border-left: 4px solid #17a2b8;">
                <h4 style="margin: 0 0 6px 0; color: #17a2b8; font-size: 0.95em; font-weight: 600;">🌊 암모니아 확산 양상</h4>
                <p style="margin: 0; font-size: 0.85em; color: #666;">암모니아가 누출되어 가장 위험한 곳을 표시합니다.</p>
              </div>
            </div>
          </div>

          <!-- Interactive Controls -->
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1d1d1f; font-size: 1.1em; font-weight: 600; margin: 0 0 12px 0; border-bottom: 2px solid #28a745; padding-bottom: 5px;">🖱️ 상호작용 방법</h3>
            
            <div style="display: grid; gap: 10px;">
              <div style="background: #fff3cd; padding: 10px; border-radius: 8px; border-left: 4px solid #ffc107;">
                <h4 style="margin: 0 0 6px 0; color: #856404; font-size: 0.9em; font-weight: 600;">데스크톱 조작</h4>
                <ul style="margin: 6px 0 0 0; padding-left: 16px; font-size: 0.8em; color: #666;">
                  <li>마우스 좌클릭 + 드래그: 시점 회전</li>
                  <li>마우스 휠: 확대/축소</li>
                  <li>마우스 우클릭 + 드래그: 카메라 이동</li>
                </ul>
              </div>
              
              <div style="background: #d1ecf1; padding: 10px; border-radius: 8px; border-left: 4px solid #17a2b8;">
                <h4 style="margin: 0 0 6px 0; color: #0c5460; font-size: 0.9em; font-weight: 600;">모바일 조작</h4>
                <ul style="margin: 6px 0 0 0; padding-left: 16px; font-size: 0.8em; color: #666;">
                  <li>햄버거 메뉴(☰): 사이드바 메뉴 열기</li>
                  <li>터치 + 드래그: 시점 회전</li>
                  <li>핀치 줌: 확대/축소</li>
                  <li>두 손가락 드래그: 카메라 이동</li>
                </ul>
              </div>
              
              <div style="background: #d4edda; padding: 10px; border-radius: 8px; border-left: 4px solid #28a745;">
                <h4 style="margin: 0 0 6px 0; color: #155724; font-size: 0.9em; font-weight: 600;">객체 클릭</h4>
                <ul style="margin: 6px 0 0 0; padding-left: 16px; font-size: 0.8em; color: #666;">
                  <li>센서 클릭: 센서 상세 정보 표시</li>
                  <li>Leak #1~6 클릭: 해당 누출원 데이터 차트 표시</li>
                  <li>Leak #7 클릭: AI 기반 실시간 탐지 시작</li>
                </ul>
              </div>
            </div>
          </div>

          <!-- Leak Data Analysis -->
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1d1d1f; font-size: 1.1em; font-weight: 600; margin: 0 0 12px 0; border-bottom: 2px solid #dc3545; padding-bottom: 5px;">📊 누출 데이터 분석</h3>
            
            <div style="background: #f8d7da; padding: 12px; border-radius: 8px; border-left: 4px solid #dc3545;">
              <h4 style="margin: 0 0 8px 0; color: #721c24; font-size: 0.95em; font-weight: 600;">Leak #1 ~ #6</h4>
              <p style="margin: 0 0 8px 0; font-size: 0.85em; color: #666;">좌측 버튼 클릭 또는 3D 모델에서 직접 클릭하여 각 누출원의 센서 데이터를 확인할 수 있습니다.</p>
              <ul style="margin: 6px 0 0 0; padding-left: 16px; font-size: 0.8em; color: #721c24;">
                <li>실시간 농도 변화 그래프</li>
                <li>센서별 반응 패턴 분석</li>
              </ul>
            </div>
          </div>

          <!-- Visual Elements -->
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1d1d1f; font-size: 1.1em; font-weight: 600; margin: 0 0 12px 0; border-bottom: 2px solid #6f42c1; padding-bottom: 5px;">🎨 시각적 요소</h3>
            
            <div style="display: grid; gap: 10px;">
              <div style="background: #e2e3e5; padding: 10px; border-radius: 8px; border-left: 4px solid #6c757d;">
                <h4 style="margin: 0 0 6px 0; color: #495057; font-size: 0.9em; font-weight: 600;">센서 표시</h4>
                <p style="margin: 0; font-size: 0.8em; color: #666;">파란색 정육면체로 표시되며, Labels 토글로 이름 표시/숨김이 가능합니다.</p>
              </div>
              
              <div style="background: #f1f3f4; padding: 10px; border-radius: 8px; border-left: 4px solid #6f42c1;">
                <h4 style="margin: 0 0 6px 0; color: #6f42c1; font-size: 0.9em; font-weight: 600;">확산 시뮬레이션</h4>
                <p style="margin: 0; font-size: 0.8em; color: #666;">
                  • 안전 구역: 연한 초록색 (농도 낮음)<br>
                  • 위험 구역: 노란색 → 주황색 → 빨간색 (농도 증가)<br>
                  • 입자 효과: 실시간 확산 패턴 시각화
                </p>
              </div>
            </div>
          </div>

          <!-- Tips & Shortcuts -->
          <div style="margin-bottom: 20px;">
            <h3 style="color: #1d1d1f; font-size: 1.1em; font-weight: 600; margin: 0 0 12px 0; border-bottom: 2px solid #fd7e14; padding-bottom: 5px;">💡 유용한 팁</h3>
            
            <div style="background: #fff3cd; padding: 12px; border-radius: 8px; border-left: 4px solid #fd7e14;">
              <ul style="margin: 0; padding-left: 16px; font-size: 0.85em; color: #856404;">
                <li><strong>ESC 키:</strong> 열려있는 팝업 창이나 사이드바를 빠르게 닫습니다</li>
                <li><strong>팝업 드래그:</strong> 팝업 상단 바를 드래그하여 위치 조정 가능</li>
                <li><strong>신경망 뷰:</strong> 휠로 확대/축소, 드래그로 이동, Reset View 버튼으로 초기화</li>
                <li><strong>모바일 메뉴:</strong> 좌상단 햄버거 메뉴(☰)로 모든 기능에 접근 가능</li>
                <li><strong>동시 실행:</strong> 여러 기능을 동시에 실행하면 이전 작업이 자동으로 정리됩니다</li>
                <li><strong>반응형 디자인:</strong> 모바일 및 태블릿에서 최적화된 인터페이스 제공</li>
                <li><strong>터치 제스처:</strong> 모바일에서 자연스러운 터치 조작 지원</li>
              </ul>
            </div>
          </div>

        </div>
      `;

      document.getElementById('popup-content').innerHTML = html;
      
      // Set popup size for guide content
      if (isMobileDevice()) {
        adjustPopupForMobile('guide');
      } else {
        popup.style.width = '500px';
        popup.style.maxWidth = '90vw';
        popup.style.height = '600px';
        popup.style.maxHeight = '80vh';
        popup.style.bottom = 'auto';
        popup.style.right = 'auto';
        popup.style.top = '50%';
        popup.style.left = '50%';
        // Preserve any existing drag position
        preservePopupPosition();
      }
      
      // Show popup with animation
      popup.classList.add('show');
    }

  </script>

</body>

</html>